<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lab Slice Manager</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #1f2937; }
    ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, createContext, useContext } = React;

    const HARDCODED_SUPABASE_URL = 'https://dcvaenscfybcfalgmrgx.supabase.co';
    const HARDCODED_SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRjdmFlbnNjZnliY2ZhbGdtcmd4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyODk4NjUsImV4cCI6MjA4NDg2NTg2NX0.FVAm8I_ycP531RHalj3wAXjPm-A15AtNDSqRk1Mfu9E';
    
    const getSupabaseConfig = () => {
      const stored = localStorage.getItem('supabase_config');
      if (stored) { try { return JSON.parse(stored); } catch (e) {} }
      return { url: HARDCODED_SUPABASE_URL, key: HARDCODED_SUPABASE_ANON_KEY };
    };
    const saveSupabaseConfig = (url, key) => localStorage.setItem('supabase_config', JSON.stringify({ url, key }));
    const config = getSupabaseConfig();
    const supabase = config.url && config.key ? window.supabase.createClient(config.url, config.key) : null;

    const Icon = ({ name, className = "w-5 h-5" }) => {
      const iconRef = useRef(null);
      useEffect(() => {
        if (iconRef.current && lucide.icons[name]) {
          iconRef.current.innerHTML = '';
          iconRef.current.appendChild(lucide.createElement(lucide.icons[name]));
        }
      }, [name]);
      return <span ref={iconRef} className={`inline-flex items-center justify-center ${className}`} />;
    };

    const DEFAULT_MOUSE_SCHEMA = [
      { key: 'mouseNumber', label: 'Mouse Number', type: 'text', required: true },
      { key: 'sex', label: 'Sex', type: 'select', options: ['M', 'F'], required: false },
      { key: 'genotype', label: 'Genotype', type: 'text', required: false },
      { key: 'labeling', label: 'Labeling', type: 'text', required: false },
      { key: 'birthDate', label: 'Birth Date', type: 'date', required: false },
      { key: 'sacrificeDate', label: 'Sacrifice Date', type: 'date', required: false },
      { key: 'ageMonths', label: 'Age (months)', type: 'number', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_SLICE_SCHEMA = [
      { key: 'region', label: 'Brain Region', type: 'multicheck', options: ['H', 'C'], required: true },
      { key: 'thickness', label: 'Thickness (Œºm)', type: 'number', required: true, default: 16 },
      { key: 'cryosectionDate', label: 'Cryosection Date', type: 'date', required: false },
      { key: 'embeddingMatrix', label: 'Embedding Matrix', type: 'select', options: ['TFM', 'OCT'], required: false, default: 'TFM' },
      { key: 'sliceNumber', label: 'Slice Number', type: 'number', required: false },
      { key: 'quality', label: 'Quality', type: 'select', options: ['Excellent', 'Good', 'Fair', 'Poor'], required: false },
      { key: 'storageLocation', label: 'Storage Location', type: 'text', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_EXPERIMENT_SCHEMA = [
      { key: 'title', label: 'Title', type: 'text', required: false },
      { key: 'experimentDate', label: 'Experiment Date', type: 'date', required: true },
      { key: 'purpose', label: 'Purpose', type: 'textarea', required: false },
      { key: 'protocol', label: 'Protocol', type: 'textarea', required: false },
      { key: 'operator', label: 'Operator', type: 'text', required: false },
      { key: 'results', label: 'Results', type: 'textarea', required: false },
      { key: 'dataFiles', label: 'Data Files', type: 'multitext', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_EXPERIMENT_SLICE_SCHEMA = [
      { key: 'treatment', label: 'Treatment', type: 'textarea', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_LABEL_CONFIG = { fontSize: 7, showExpId: true, showSliceId: true, showMouseInfo: true, showSliceInfo: true, showTreatment: true, labelWidth: 38, labelMaxWidth: 50 };

    function generateId(prefix) {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let id = '';
      for (let i = 0; i < 6; i++) id += chars[Math.floor(Math.random() * chars.length)];
      return `${prefix}-${id.slice(0,4)}-${id.slice(4)}${chars[Math.floor(Math.random() * chars.length)]}${chars[Math.floor(Math.random() * chars.length)]}`;
    }

    function getMouseAge(mouse) {
      if (!mouse) return { months: null, remainingDays: null, isManual: false };
      if (mouse.birthDate) {
        const birth = new Date(mouse.birthDate);
        const ref = mouse.sacrificeDate ? new Date(mouse.sacrificeDate) : new Date();
        const totalDays = Math.floor((ref - birth) / (1000 * 60 * 60 * 24));
        return { months: Math.floor(totalDays / 30.44), remainingDays: Math.floor(totalDays % 30.44), isManual: false };
      }
      if (mouse.ageMonths !== null && mouse.ageMonths !== undefined && mouse.ageMonths !== '') {
        return { months: Number(mouse.ageMonths), remainingDays: null, isManual: true };
      }
      return { months: null, remainingDays: null, isManual: false };
    }

    function abbrevSex(sex) { if (!sex) return '?'; if (sex === 'Male' || sex === 'M') return 'M'; if (sex === 'Female' || sex === 'F') return 'F'; return sex; }
    function abbrevRegion(region) {
      if (!region) return '?';
      if (Array.isArray(region)) return region.map(r => r === 'Hippocampus' || r === 'H' ? 'H' : r === 'Cortex' || r === 'C' ? 'C' : r).join('/');
      return region === 'Hippocampus' ? 'H' : region === 'Cortex' ? 'C' : region;
    }

    const DataContext = createContext(null);
    const useData = () => useContext(DataContext);

    function App() {
      const [user, setUser] = useState(null);
      const [authLoading, setAuthLoading] = useState(true);
      const [mice, setMice] = useState([]);
      const [slices, setSlices] = useState([]);
      const [experiments, setExperiments] = useState([]);
      const [experimentSlices, setExperimentSlices] = useState([]);
      const [mouseSchema, setMouseSchema] = useState(DEFAULT_MOUSE_SCHEMA);
      const [sliceSchema, setSliceSchema] = useState(DEFAULT_SLICE_SCHEMA);
      const [experimentSchema, setExperimentSchema] = useState(DEFAULT_EXPERIMENT_SCHEMA);
      const [experimentSliceSchema, setExperimentSliceSchema] = useState(DEFAULT_EXPERIMENT_SLICE_SCHEMA);
      const [labelConfig, setLabelConfig] = useState(DEFAULT_LABEL_CONFIG);
      const [dataLoaded, setDataLoaded] = useState(false);

      useEffect(() => {
        if (supabase) {
          supabase.auth.getSession().then(({ data: { session } }) => { setUser(session?.user ?? null); setAuthLoading(false); });
          const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => setUser(session?.user ?? null));
          return () => subscription.unsubscribe();
        } else { setAuthLoading(false); }
      }, []);

      useEffect(() => { if (user && !dataLoaded) loadData(); }, [user, dataLoaded]);

      const mergeSchemas = (defaultSchema, savedSchema) => {
        const defaultByKey = {}; defaultSchema.forEach(f => { defaultByKey[f.key] = f; });
        const savedKeys = new Set(savedSchema.map(f => f.key));
        const newFields = defaultSchema.filter(f => !savedKeys.has(f.key));
        const updatedSaved = savedSchema.map(f => defaultByKey[f.key] ? { ...f, required: defaultByKey[f.key].required } : f);
        return [...newFields, ...updatedSaved];
      };

      const loadData = async () => {
        if (supabase && user && !user.offline) {
          try {
            const [miceRes, slicesRes, expRes, expSlicesRes, schemaRes] = await Promise.all([
              supabase.from('mice').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('slices').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('experiments').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('experiment_slices').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('user_settings').select('*').eq('user_id', user.id).single(),
            ]);
            if (miceRes.data) setMice(miceRes.data);
            if (slicesRes.data) setSlices(slicesRes.data);
            if (expRes.data) setExperiments(expRes.data);
            if (expSlicesRes.data) setExperimentSlices(expSlicesRes.data);
            if (schemaRes.data) {
              if (schemaRes.data.mouse_schema) setMouseSchema(mergeSchemas(DEFAULT_MOUSE_SCHEMA, schemaRes.data.mouse_schema));
              if (schemaRes.data.slice_schema) setSliceSchema(mergeSchemas(DEFAULT_SLICE_SCHEMA, schemaRes.data.slice_schema));
              if (schemaRes.data.experiment_schema) setExperimentSchema(mergeSchemas(DEFAULT_EXPERIMENT_SCHEMA, schemaRes.data.experiment_schema));
              if (schemaRes.data.experiment_slice_schema) setExperimentSliceSchema(mergeSchemas(DEFAULT_EXPERIMENT_SLICE_SCHEMA, schemaRes.data.experiment_slice_schema));
              if (schemaRes.data.label_config) setLabelConfig(schemaRes.data.label_config);
            }
          } catch (err) { console.error('Load error:', err); loadFromLocalStorage(); }
        } else { loadFromLocalStorage(); }
        setDataLoaded(true);
      };
      
      const loadFromLocalStorage = () => {
        const load = (key, setter, defSchema) => {
          const saved = localStorage.getItem(key);
          if (saved) { const parsed = JSON.parse(saved); setter(defSchema ? mergeSchemas(defSchema, parsed) : parsed); }
        };
        load('labManager_mice', setMice); load('labManager_slices', setSlices);
        load('labManager_experiments', setExperiments); load('labManager_experimentSlices', setExperimentSlices);
        load('labManager_mouseSchema', setMouseSchema, DEFAULT_MOUSE_SCHEMA);
        load('labManager_sliceSchema', setSliceSchema, DEFAULT_SLICE_SCHEMA);
        load('labManager_experimentSchema', setExperimentSchema, DEFAULT_EXPERIMENT_SCHEMA);
        load('labManager_experimentSliceSchema', setExperimentSliceSchema, DEFAULT_EXPERIMENT_SLICE_SCHEMA);
        load('labManager_labelConfig', setLabelConfig);
      };

      useEffect(() => {
        if (dataLoaded) {
          localStorage.setItem('labManager_mice', JSON.stringify(mice));
          localStorage.setItem('labManager_slices', JSON.stringify(slices));
          localStorage.setItem('labManager_experiments', JSON.stringify(experiments));
          localStorage.setItem('labManager_experimentSlices', JSON.stringify(experimentSlices));
          localStorage.setItem('labManager_mouseSchema', JSON.stringify(mouseSchema));
          localStorage.setItem('labManager_sliceSchema', JSON.stringify(sliceSchema));
          localStorage.setItem('labManager_experimentSchema', JSON.stringify(experimentSchema));
          localStorage.setItem('labManager_experimentSliceSchema', JSON.stringify(experimentSliceSchema));
          localStorage.setItem('labManager_labelConfig', JSON.stringify(labelConfig));
        }
      }, [mice, slices, experiments, experimentSlices, mouseSchema, sliceSchema, experimentSchema, experimentSliceSchema, labelConfig, dataLoaded]);

      useEffect(() => {
        if (supabase && user && !user.offline && dataLoaded) {
          const timer = setTimeout(async () => {
            await supabase.from('user_settings').upsert({
              user_id: user.id, mouse_schema: mouseSchema, slice_schema: sliceSchema,
              experiment_schema: experimentSchema, experiment_slice_schema: experimentSliceSchema,
              label_config: labelConfig, updated_at: new Date().toISOString(),
            });
          }, 2000);
          return () => clearTimeout(timer);
        }
      }, [mouseSchema, sliceSchema, experimentSchema, experimentSliceSchema, labelConfig]);

      const contextValue = { mice, setMice, slices, setSlices, experiments, setExperiments, experimentSlices, setExperimentSlices, mouseSchema, setMouseSchema, sliceSchema, setSliceSchema, experimentSchema, setExperimentSchema, experimentSliceSchema, setExperimentSliceSchema, labelConfig, setLabelConfig, user, supabase };

      if (authLoading) return <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center"><div className="animate-spin"><Icon name="Loader2" className="w-8 h-8" /></div></div>;
      if (!user) return <AuthScreen setUser={setUser} />;
      return <DataContext.Provider value={contextValue}><MainLayout /></DataContext.Provider>;
    }

    function AuthScreen({ setUser }) {
      const [email, setEmail] = useState(''); const [otp, setOtp] = useState(''); const [step, setStep] = useState('email');
      const [loading, setLoading] = useState(false); const [message, setMessage] = useState('');
      const [showConfig, setShowConfig] = useState(false);
      const [configUrl, setConfigUrl] = useState(getSupabaseConfig().url);
      const [configKey, setConfigKey] = useState(getSupabaseConfig().key);

      const sendMagicLink = async () => {
        if (!supabase) { setMessage('Configure Supabase first'); return; }
        setLoading(true); setMessage('');
        try {
          const { error } = await supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: window.location.href.split('?')[0] } });
          if (error) throw error;
          setStep('otp'); setMessage('Check email for code or magic link.');
        } catch (err) { setMessage('Error: ' + err.message); }
        setLoading(false);
      };

      const verifyOtp = async () => {
        setLoading(true); setMessage('');
        try {
          const { error } = await supabase.auth.verifyOtp({ email, token: otp, type: 'email' });
          if (error) throw error;
        } catch (err) { setMessage('Error: ' + err.message); }
        setLoading(false);
      };

      const saveConfig = () => { saveSupabaseConfig(configUrl, configKey); window.location.reload(); };

      return (
        <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4">
          <div className="bg-gray-800 rounded-xl p-8 max-w-md w-full border border-gray-700">
            <div className="text-center mb-6">
              <div className="text-4xl mb-2">üß†</div>
              <h1 className="text-2xl font-bold">Lab Slice Manager</h1>
              <p className="text-gray-400 text-sm mt-1">v3.0</p>
            </div>
            {!showConfig ? (
              <>
                {supabase ? (
                  <div className="space-y-4">
                    {step === 'email' ? (
                      <>
                        <input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg" />
                        <button onClick={sendMagicLink} disabled={loading || !email} className="w-full py-3 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded-lg">{loading ? 'Sending...' : 'Send Magic Link'}</button>
                      </>
                    ) : (
                      <>
                        <input type="text" placeholder="000000" value={otp} onChange={(e) => setOtp(e.target.value.replace(/\D/g, '').slice(0, 6))} className="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-center text-2xl tracking-widest" maxLength={6} />
                        <button onClick={verifyOtp} disabled={loading || otp.length !== 6} className="w-full py-3 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded-lg">{loading ? 'Verifying...' : 'Verify'}</button>
                        <button onClick={() => setStep('email')} className="w-full py-2 text-gray-400 text-sm">‚Üê Back</button>
                      </>
                    )}
                    {message && <p className="text-sm text-center text-yellow-400">{message}</p>}
                    <div className="border-t border-gray-700 my-4"></div>
                    <button onClick={() => setUser({ offline: true, id: 'offline-user' })} className="w-full py-3 bg-gray-700 hover:bg-gray-600 rounded-lg">Continue Offline</button>
                  </div>
                ) : (
                  <div className="space-y-4">
                    <button onClick={() => setShowConfig(true)} className="w-full py-3 bg-purple-600 hover:bg-purple-700 rounded-lg">Configure Supabase</button>
                    <button onClick={() => setUser({ offline: true, id: 'offline-user' })} className="w-full py-3 bg-gray-700 hover:bg-gray-600 rounded-lg">Continue Offline</button>
                  </div>
                )}
                <button onClick={() => setShowConfig(true)} className="w-full mt-4 py-2 text-gray-500 hover:text-gray-300 text-sm">‚öôÔ∏è Supabase Settings</button>
              </>
            ) : (
              <div className="space-y-4">
                <input type="text" placeholder="https://xxx.supabase.co" value={configUrl} onChange={(e) => setConfigUrl(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-sm" />
                <input type="text" placeholder="anon key" value={configKey} onChange={(e) => setConfigKey(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-sm" />
                <div className="flex gap-2">
                  <button onClick={() => setShowConfig(false)} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
                  <button onClick={saveConfig} className="flex-1 py-2 bg-purple-600 rounded-lg">Save</button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function MainLayout() {
      const { user, supabase, mice, slices, experiments, experimentSlices, setMice, setSlices, setExperiments, setExperimentSlices } = useData();
      const [activeTab, setActiveTab] = useState('mice');
      const [showSettings, setShowSettings] = useState(false);
      const [showExport, setShowExport] = useState(false);

      const exportData = () => {
        const data = { mice, slices, experiments, experimentSlices, exportedAt: new Date().toISOString(), version: '3.0' };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `backup-${new Date().toISOString().split('T')[0]}.json`; a.click();
      };

      const importData = (e) => {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const data = JSON.parse(event.target.result);
            if (data.mice) setMice(data.mice);
            if (data.slices) setSlices(data.slices);
            if (data.experiments) setExperiments(data.experiments);
            if (data.experimentSlices) setExperimentSlices(data.experimentSlices);
            if (supabase && user && !user.offline) {
              for (const m of (data.mice || [])) await supabase.from('mice').upsert({ ...m, user_id: user.id });
              for (const s of (data.slices || [])) await supabase.from('slices').upsert({ ...s, user_id: user.id });
              for (const exp of (data.experiments || [])) await supabase.from('experiments').upsert({ ...exp, user_id: user.id });
              for (const es of (data.experimentSlices || [])) await supabase.from('experiment_slices').upsert({ ...es, user_id: user.id });
            }
            alert('Imported!');
          } catch (err) { alert('Error: ' + err.message); }
        };
        reader.readAsText(file);
      };

      const tabs = [{ key: 'mice', label: 'Mice', icon: 'Mouse' }, { key: 'slices', label: 'Slices', icon: 'Layers' }, { key: 'experiments', label: 'Experiments', icon: 'FlaskConical' }, { key: 'labels', label: 'Labels', icon: 'Tag' }];

      return (
        <div className="min-h-screen bg-gray-900 text-white">
          <header className="bg-gray-800 border-b border-gray-700 sticky top-0 z-40">
            <div className="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
              <div className="flex items-center gap-3"><span className="text-2xl">üß†</span><span className="font-semibold hidden sm:block">Lab Slice Manager</span></div>
              <div className="flex items-center gap-2">
                <button onClick={() => setShowExport(true)} className="p-2 hover:bg-gray-700 rounded-lg"><Icon name="Database" className="w-5 h-5" /></button>
                <button onClick={() => setShowSettings(true)} className="p-2 hover:bg-gray-700 rounded-lg"><Icon name="Settings" className="w-5 h-5" /></button>
                <button onClick={() => { if (supabase && !user.offline) supabase.auth.signOut(); window.location.reload(); }} className="p-2 hover:bg-gray-700 rounded-lg text-gray-400"><Icon name="LogOut" className="w-5 h-5" /></button>
              </div>
            </div>
            <nav className="max-w-7xl mx-auto px-4 flex gap-1 overflow-x-auto">
              {tabs.map(tab => <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex items-center gap-2 px-4 py-2 rounded-t-lg ${activeTab === tab.key ? 'bg-gray-900 text-white' : 'text-gray-400 hover:bg-gray-700/50'}`}><Icon name={tab.icon} className="w-4 h-4" />{tab.label}</button>)}
            </nav>
          </header>
          <main className="max-w-7xl mx-auto p-4">
            {activeTab === 'mice' && <MiceTab />}
            {activeTab === 'slices' && <SlicesTab />}
            {activeTab === 'experiments' && <ExperimentsTab />}
            {activeTab === 'labels' && <LabelsTab />}
          </main>
          {showSettings && <Modal title="Settings" onClose={() => setShowSettings(false)} large><SettingsPanel onClose={() => setShowSettings(false)} /></Modal>}
          {showExport && <Modal title="Import/Export" onClose={() => setShowExport(false)}>
            <div className="space-y-4">
              <button onClick={exportData} className="w-full py-3 bg-purple-600 hover:bg-purple-700 rounded-lg">Export Data</button>
              <label className="w-full py-3 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center cursor-pointer">Import<input type="file" accept=".json" onChange={importData} className="hidden" /></label>
            </div>
          </Modal>}
        </div>
      );
    }

    function SortableHeader({ label, sortKey, currentSort, onSort }) {
      const isActive = currentSort.key === sortKey;
      return <th className="px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase cursor-pointer hover:text-white" onClick={() => onSort(sortKey)}>{label} {isActive && (currentSort.direction === 'asc' ? '‚Üë' : '‚Üì')}</th>;
    }

    function MiceTab() {
      const { mice, setMice, slices, mouseSchema, user, supabase } = useData();
      const [showAdd, setShowAdd] = useState(false);
      const [editingMouse, setEditingMouse] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [sort, setSort] = useState({ key: 'created_at', direction: 'desc' });

      const handleSort = (key) => setSort(prev => ({ key, direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc' }));

      const sortedMice = useMemo(() => {
        let filtered = mice.filter(m => !searchTerm || Object.values(m).some(v => String(v).toLowerCase().includes(searchTerm.toLowerCase())));
        return filtered.sort((a, b) => {
          let aVal, bVal;
          if (sort.key === 'age') { const ageA = getMouseAge(a); const ageB = getMouseAge(b); aVal = ageA.months ?? -1; bVal = ageB.months ?? -1; }
          else { aVal = a[sort.key] ?? ''; bVal = b[sort.key] ?? ''; }
          return sort.direction === 'asc' ? (aVal < bVal ? -1 : 1) : (aVal > bVal ? -1 : 1);
        });
      }, [mice, searchTerm, sort]);

      const addMouse = async (data) => {
        const newMouse = { id: generateId('M'), ...data, created_at: new Date().toISOString() };
        setMice([newMouse, ...mice]); setShowAdd(false);
        if (supabase && user && !user.offline) {
          const { error } = await supabase.from('mice').insert({ ...newMouse, user_id: user.id });
          if (error) alert('Cloud error: ' + error.message);
        }
      };

      const updateMouse = async (data) => {
        setMice(mice.map(m => m.id === editingMouse.id ? { ...m, ...data } : m)); setEditingMouse(null);
        if (supabase && user && !user.offline) await supabase.from('mice').update(data).eq('id', editingMouse.id);
      };

      const deleteMouse = async (id) => {
        if (slices.some(s => s.mouseId === id)) { alert('Delete slices first'); return; }
        if (!confirm('Delete?')) return;
        setMice(mice.filter(m => m.id !== id));
        if (supabase && user && !user.offline) await supabase.from('mice').delete().eq('id', id);
      };

      return (
        <div>
          <div className="flex gap-2 mb-4 flex-wrap">
            <input type="text" placeholder="Search..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
            <button onClick={() => setShowAdd(true)} className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg flex items-center gap-2"><Icon name="Plus" className="w-4 h-4" />Add Mouse</button>
          </div>
          <div className="flex gap-2 mb-3 text-xs flex-wrap">
            {[{ key: 'mouseNumber', label: 'Mouse#' }, { key: 'sex', label: 'Sex' }, { key: 'age', label: 'Age' }, { key: 'created_at', label: 'Added' }].map(({ key, label }) => (
              <button key={key} onClick={() => handleSort(key)} className={`px-2 py-1 rounded ${sort.key === key ? 'bg-purple-600' : 'bg-gray-700'}`}>{label}</button>
            ))}
          </div>
          <div className="overflow-x-auto bg-gray-800 rounded-lg border border-gray-700">
            <table className="w-full">
              <thead className="bg-gray-900/50"><tr>
                <SortableHeader label="Mouse#" sortKey="mouseNumber" currentSort={sort} onSort={handleSort} />
                <th className="px-3 py-2 text-left text-xs text-gray-400">Sex</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Genotype</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Labeling</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Age</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Slices</th>
                <th className="px-3 py-2 text-right text-xs text-gray-400">Actions</th>
              </tr></thead>
              <tbody className="divide-y divide-gray-700">
                {sortedMice.length === 0 ? <tr><td colSpan="7" className="py-8 text-center text-gray-500">No mice</td></tr> : sortedMice.map(mouse => {
                  const age = getMouseAge(mouse);
                  return (
                    <tr key={mouse.id} className="hover:bg-gray-700/50">
                      <td className="px-3 py-2 font-medium">{mouse.mouseNumber || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{mouse.sex || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{mouse.genotype || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{mouse.labeling || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{age.months !== null ? `${age.months}m${age.remainingDays ? ` ${age.remainingDays}d` : ''}` : 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{slices.filter(s => s.mouseId === mouse.id).length}</td>
                      <td className="px-3 py-2 text-right">
                        <button onClick={() => setEditingMouse(mouse)} className="p-1 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                        <button onClick={() => deleteMouse(mouse.id)} className="p-1 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
          {showAdd && <Modal title="Add Mouse" onClose={() => setShowAdd(false)}><DynamicForm schema={mouseSchema} onSubmit={addMouse} onCancel={() => setShowAdd(false)} submitLabel="Add" /></Modal>}
          {editingMouse && <Modal title="Edit Mouse" onClose={() => setEditingMouse(null)}><DynamicForm schema={mouseSchema} initialData={editingMouse} onSubmit={updateMouse} onCancel={() => setEditingMouse(null)} submitLabel="Save" /></Modal>}
        </div>
      );
    }

    function SlicesTab() {
      const { mice, slices, setSlices, experiments, experimentSlices, setExperimentSlices, setExperiments, sliceSchema, experimentSchema, user, supabase } = useData();
      const [showAdd, setShowAdd] = useState(false);
      const [addingSliceForMouse, setAddingSliceForMouse] = useState(null);
      const [editingSlice, setEditingSlice] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [sort, setSort] = useState({ key: 'created_at', direction: 'desc' });
      const [addingExpForSlice, setAddingExpForSlice] = useState(null);

      const sortedSlices = useMemo(() => {
        let filtered = slices.filter(s => {
          if (!searchTerm) return true;
          const mouse = mice.find(m => m.id === s.mouseId);
          const searchLower = searchTerm.toLowerCase();
          return s.id.toLowerCase().includes(searchLower) || (mouse?.mouseNumber || '').toLowerCase().includes(searchLower) || (s.region?.join(' ') || '').toLowerCase().includes(searchLower);
        });
        return filtered.sort((a, b) => {
          let aVal = a[sort.key] ?? '', bVal = b[sort.key] ?? '';
          return sort.direction === 'asc' ? (aVal < bVal ? -1 : 1) : (aVal > bVal ? -1 : 1);
        });
      }, [slices, mice, searchTerm, sort]);

      const addSlice = async (data) => {
        const newSlice = { id: generateId('S'), mouseId: addingSliceForMouse.id, ...data, created_at: new Date().toISOString() };
        setSlices([newSlice, ...slices]); setShowAdd(false); setAddingSliceForMouse(null);
        if (supabase && user && !user.offline) await supabase.from('slices').insert({ ...newSlice, user_id: user.id });
      };

      const updateSlice = async (data) => {
        setSlices(slices.map(s => s.id === editingSlice.id ? { ...s, ...data } : s)); setEditingSlice(null);
        if (supabase && user && !user.offline) await supabase.from('slices').update(data).eq('id', editingSlice.id);
      };

      const deleteSlice = async (id) => {
        if (experimentSlices.some(es => es.sliceId === id)) { alert('Remove from experiments first'); return; }
        if (!confirm('Delete?')) return;
        setSlices(slices.filter(s => s.id !== id));
        if (supabase && user && !user.offline) await supabase.from('slices').delete().eq('id', id);
      };

      return (
        <div>
          <div className="flex gap-2 mb-4 flex-wrap">
            <input type="text" placeholder="Search..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
          </div>
          <div className="mb-4 p-3 bg-gray-800 rounded-lg border border-gray-700">
            <div className="text-sm text-gray-400 mb-2">Add slice for:</div>
            <div className="flex flex-wrap gap-2">
              {mice.map(m => <button key={m.id} onClick={() => { setAddingSliceForMouse(m); setShowAdd(true); }} className="px-3 py-1.5 bg-purple-600/30 hover:bg-purple-600/50 border border-purple-500/50 rounded-lg text-sm">{m.mouseNumber} ({abbrevSex(m.sex)})</button>)}
              {mice.length === 0 && <span className="text-gray-500 text-sm">Add a mouse first</span>}
            </div>
          </div>
          <div className="grid gap-2">
            {sortedSlices.length === 0 ? <div className="bg-gray-800 rounded-lg border border-gray-700 p-8 text-center text-gray-500">No slices</div> : sortedSlices.map(slice => {
              const mouse = mice.find(m => m.id === slice.mouseId);
              const age = getMouseAge(mouse);
              const expCount = experimentSlices.filter(es => es.sliceId === slice.id).length;
              return (
                <div key={slice.id} className="bg-gray-800 rounded-lg border border-gray-700 p-3 flex items-center justify-between">
                  <div className="flex items-center gap-2 flex-wrap text-sm">
                    <span className="font-mono text-blue-400">{slice.id}</span>
                    <span className="text-gray-500">|</span>
                    <span className="text-purple-400">{mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{age?.months ?? '?'}m/{mouse?.genotype || '?'}</span>
                    <span className="text-gray-500">|</span>
                    <span className="text-green-400">{abbrevRegion(slice.region)}/{slice.thickness}Œºm</span>
                    {expCount > 0 && <span className="text-orange-400 text-xs">({expCount} exp)</span>}
                  </div>
                  <div className="flex items-center gap-1">
                    <button onClick={() => setAddingExpForSlice(slice)} className="p-1.5 hover:bg-purple-600/30 rounded text-purple-400" title="Add to Experiment"><Icon name="FlaskConical" className="w-4 h-4" /></button>
                    <button onClick={() => setEditingSlice(slice)} className="p-1.5 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                    <button onClick={() => deleteSlice(slice.id)} className="p-1.5 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                  </div>
                </div>
              );
            })}
          </div>
          {showAdd && addingSliceForMouse && <Modal title="Add Slice" onClose={() => { setShowAdd(false); setAddingSliceForMouse(null); }}>
            <div className="mb-4 p-3 bg-purple-600/20 rounded-lg border border-purple-500/30">For: {addingSliceForMouse.mouseNumber} ({abbrevSex(addingSliceForMouse.sex)})</div>
            <DynamicForm schema={sliceSchema} onSubmit={addSlice} onCancel={() => { setShowAdd(false); setAddingSliceForMouse(null); }} submitLabel="Add" />
          </Modal>}
          {editingSlice && <Modal title="Edit Slice" onClose={() => setEditingSlice(null)}><DynamicForm schema={sliceSchema} initialData={editingSlice} onSubmit={updateSlice} onCancel={() => setEditingSlice(null)} submitLabel="Save" /></Modal>}
          {addingExpForSlice && <AddSliceToExpModal slice={addingExpForSlice} onClose={() => setAddingExpForSlice(null)} />}
        </div>
      );
    }

    function AddSliceToExpModal({ slice, onClose }) {
      const { mice, experiments, experimentSlices, setExperiments, setExperimentSlices, experimentSchema, user, supabase } = useData();
      const [mode, setMode] = useState('choose');
      const [selectedExp, setSelectedExp] = useState(null);
      const [treatment, setTreatment] = useState('');
      const [notes, setNotes] = useState('');

      const mouse = mice.find(m => m.id === slice.mouseId);
      const availableExps = experiments.filter(exp => !experimentSlices.some(es => es.experimentId === exp.id && es.sliceId === slice.id));

      const createNewExp = async (expData) => {
        const newExp = { id: generateId('E'), ...expData, created_at: new Date().toISOString() };
        setExperiments([newExp, ...experiments]);
        if (supabase && user && !user.offline) await supabase.from('experiments').insert({ ...newExp, user_id: user.id });
        const newLink = { id: generateId('ES'), experimentId: newExp.id, sliceId: slice.id, treatment, notes, created_at: new Date().toISOString() };
        setExperimentSlices([newLink, ...experimentSlices]);
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').insert({ ...newLink, user_id: user.id });
        onClose();
      };

      const addToExisting = async () => {
        if (!selectedExp) return;
        const newLink = { id: generateId('ES'), experimentId: selectedExp, sliceId: slice.id, treatment, notes, created_at: new Date().toISOString() };
        setExperimentSlices([newLink, ...experimentSlices]);
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').insert({ ...newLink, user_id: user.id });
        onClose();
      };

      return (
        <Modal title="Add to Experiment" onClose={onClose} large>
          <div className="mb-4 p-3 bg-blue-600/20 rounded-lg border border-blue-500/30">
            <span className="font-mono text-blue-400">{slice.id}</span> | {mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{abbrevRegion(slice.region)}
          </div>
          {mode === 'choose' && (
            <div className="space-y-3">
              <button onClick={() => setMode('new')} className="w-full p-4 bg-purple-600/20 hover:bg-purple-600/30 border border-purple-500/50 rounded-lg text-left">
                <div className="font-medium">Create New Experiment</div>
              </button>
              <button onClick={() => setMode('existing')} disabled={availableExps.length === 0} className="w-full p-4 bg-green-600/20 hover:bg-green-600/30 disabled:bg-gray-700/50 border border-green-500/50 disabled:border-gray-600 rounded-lg text-left">
                <div className="font-medium">Add to Existing ({availableExps.length})</div>
              </button>
            </div>
          )}
          {mode === 'new' && (
            <div>
              <button onClick={() => setMode('choose')} className="mb-4 text-sm text-gray-400 hover:text-white">‚Üê Back</button>
              <div className="mb-4"><label className="block text-sm text-gray-400 mb-1">Treatment (optional)</label>
                <textarea value={treatment} onChange={(e) => setTreatment(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" rows={2} />
              </div>
              <DynamicForm schema={experimentSchema} onSubmit={createNewExp} onCancel={onClose} submitLabel="Create & Add" />
            </div>
          )}
          {mode === 'existing' && (
            <div>
              <button onClick={() => setMode('choose')} className="mb-4 text-sm text-gray-400 hover:text-white">‚Üê Back</button>
              <select value={selectedExp || ''} onChange={(e) => setSelectedExp(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg mb-3">
                <option value="">Select...</option>
                {availableExps.map(exp => <option key={exp.id} value={exp.id}>{exp.id} - {exp.title || 'Untitled'}</option>)}
              </select>
              <div className="mb-3"><label className="block text-sm text-gray-400 mb-1">Treatment</label>
                <textarea value={treatment} onChange={(e) => setTreatment(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" rows={2} />
              </div>
              <div className="flex gap-2">
                <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
                <button onClick={addToExisting} disabled={!selectedExp} className="flex-1 py-2 bg-purple-600 disabled:bg-gray-600 rounded-lg">Add</button>
              </div>
            </div>
          )}
        </Modal>
      );
    }

    function ExperimentsTab() {
      const { mice, slices, experiments, setExperiments, experimentSlices, setExperimentSlices, experimentSchema, user, supabase } = useData();
      const [showAdd, setShowAdd] = useState(false);
      const [editingExp, setEditingExp] = useState(null);
      const [expandedExp, setExpandedExp] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [addingSliceToExp, setAddingSliceToExp] = useState(null);
      const [editingExpSlice, setEditingExpSlice] = useState(null);

      const sortedExps = useMemo(() => {
        return experiments.filter(exp => !searchTerm || exp.id.toLowerCase().includes(searchTerm.toLowerCase()) || (exp.title || '').toLowerCase().includes(searchTerm.toLowerCase()))
          .sort((a, b) => (b.created_at || '').localeCompare(a.created_at || ''));
      }, [experiments, searchTerm]);

      const addExp = async (data) => {
        const newExp = { id: generateId('E'), ...data, created_at: new Date().toISOString() };
        setExperiments([newExp, ...experiments]); setShowAdd(false);
        if (supabase && user && !user.offline) await supabase.from('experiments').insert({ ...newExp, user_id: user.id });
      };

      const updateExp = async (data) => {
        setExperiments(experiments.map(e => e.id === editingExp.id ? { ...e, ...data } : e)); setEditingExp(null);
        if (supabase && user && !user.offline) await supabase.from('experiments').update(data).eq('id', editingExp.id);
      };

      const deleteExp = async (id) => {
        const links = experimentSlices.filter(es => es.experimentId === id);
        if (links.length > 0 && !confirm(`Delete experiment and ${links.length} slice link(s)?`)) return;
        if (links.length === 0 && !confirm('Delete?')) return;
        setExperimentSlices(experimentSlices.filter(es => es.experimentId !== id));
        setExperiments(experiments.filter(e => e.id !== id));
        if (supabase && user && !user.offline) {
          await supabase.from('experiment_slices').delete().eq('experimentId', id);
          await supabase.from('experiments').delete().eq('id', id);
        }
      };

      const removeSliceLink = async (esId) => {
        if (!confirm('Remove slice from experiment?')) return;
        setExperimentSlices(experimentSlices.filter(es => es.id !== esId));
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').delete().eq('id', esId);
      };

      const getExpSlices = (expId) => experimentSlices.filter(es => es.experimentId === expId).map(es => {
        const slice = slices.find(s => s.id === es.sliceId);
        const mouse = slice ? mice.find(m => m.id === slice.mouseId) : null;
        return { ...es, slice, mouse };
      });

      return (
        <div>
          <div className="flex gap-2 mb-4 flex-wrap">
            <input type="text" placeholder="Search..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
            <button onClick={() => setShowAdd(true)} className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg flex items-center gap-2"><Icon name="Plus" className="w-4 h-4" />New Experiment</button>
          </div>
          <div className="space-y-3">
            {sortedExps.length === 0 ? <div className="bg-gray-800 rounded-lg border border-gray-700 p-8 text-center text-gray-500">No experiments</div> : sortedExps.map(exp => {
              const expSlices = getExpSlices(exp.id);
              const isExpanded = expandedExp === exp.id;
              return (
                <div key={exp.id} className="bg-gray-800 rounded-lg border border-gray-700 overflow-hidden">
                  <div className="p-3 flex items-center justify-between cursor-pointer hover:bg-gray-700/50" onClick={() => setExpandedExp(isExpanded ? null : exp.id)}>
                    <div className="flex items-center gap-2 text-sm">
                      <Icon name={isExpanded ? 'ChevronDown' : 'ChevronRight'} className="w-5 h-5 text-gray-400" />
                      <span className="font-mono text-green-400">{exp.id}</span>
                      {exp.title && <span className="text-white">| {exp.title}</span>}
                      {exp.experimentDate && <span className="text-gray-400">| {new Date(exp.experimentDate).toLocaleDateString()}</span>}
                      <span className="text-orange-400">| {expSlices.length} slice(s)</span>
                    </div>
                    <div className="flex items-center gap-1" onClick={(e) => e.stopPropagation()}>
                      <button onClick={() => setAddingSliceToExp(exp)} className="p-1.5 hover:bg-purple-600/30 rounded text-purple-400"><Icon name="Plus" className="w-4 h-4" /></button>
                      <button onClick={() => setEditingExp(exp)} className="p-1.5 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                      <button onClick={() => deleteExp(exp.id)} className="p-1.5 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                    </div>
                  </div>
                  {isExpanded && (
                    <div className="border-t border-gray-700 p-3 bg-gray-900/50">
                      {exp.purpose && <div className="text-sm mb-2"><span className="text-gray-500">Purpose: </span>{exp.purpose}</div>}
                      {exp.protocol && <div className="text-sm mb-2 whitespace-pre-wrap"><span className="text-gray-500">Protocol: </span>{exp.protocol}</div>}
                      <div className="mt-3 text-sm font-medium text-gray-400 mb-2">Slices:</div>
                      {expSlices.length === 0 ? <div className="text-gray-500 text-sm italic">No slices</div> : (
                        <div className="space-y-2">
                          {expSlices.map(({ id, slice, mouse, treatment }) => {
                            const age = getMouseAge(mouse);
                            return (
                              <div key={id} className="bg-gray-800 rounded-lg p-2 flex items-center justify-between text-sm">
                                <div>
                                  <span className="font-mono text-blue-400">{slice?.id || '?'}</span>
                                  <span className="text-purple-400 ml-2">{mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{age?.months ?? '?'}m</span>
                                  <span className="text-green-400 ml-2">{abbrevRegion(slice?.region)}/{slice?.thickness}Œºm</span>
                                  {treatment && <div className="text-yellow-400 text-xs mt-1">‚Üí {treatment}</div>}
                                </div>
                                <div className="flex gap-1">
                                  <button onClick={() => setEditingExpSlice({ id, treatment })} className="p-1 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-3 h-3" /></button>
                                  <button onClick={() => removeSliceLink(id)} className="p-1 hover:bg-red-600/30 rounded text-red-400"><Icon name="X" className="w-3 h-3" /></button>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
          {showAdd && <Modal title="New Experiment" onClose={() => setShowAdd(false)} large><DynamicForm schema={experimentSchema} onSubmit={addExp} onCancel={() => setShowAdd(false)} submitLabel="Create" /></Modal>}
          {editingExp && <Modal title="Edit Experiment" onClose={() => setEditingExp(null)} large><DynamicForm schema={experimentSchema} initialData={editingExp} onSubmit={updateExp} onCancel={() => setEditingExp(null)} submitLabel="Save" /></Modal>}
          {addingSliceToExp && <AddSliceToExpFromExpTab experiment={addingSliceToExp} onClose={() => setAddingSliceToExp(null)} />}
          {editingExpSlice && <EditExpSliceModal expSlice={editingExpSlice} onClose={() => setEditingExpSlice(null)} />}
        </div>
      );
    }

    function AddSliceToExpFromExpTab({ experiment, onClose }) {
      const { mice, slices, experimentSlices, setExperimentSlices, user, supabase } = useData();
      const [selectedSlice, setSelectedSlice] = useState(null);
      const [treatment, setTreatment] = useState('');

      const availableSlices = slices.filter(s => !experimentSlices.some(es => es.experimentId === experiment.id && es.sliceId === s.id));

      const addSlice = async () => {
        if (!selectedSlice) return;
        const newLink = { id: generateId('ES'), experimentId: experiment.id, sliceId: selectedSlice, treatment, created_at: new Date().toISOString() };
        setExperimentSlices([newLink, ...experimentSlices]);
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').insert({ ...newLink, user_id: user.id });
        onClose();
      };

      return (
        <Modal title="Add Slice" onClose={onClose}>
          <div className="mb-4 p-3 bg-green-600/20 rounded-lg border border-green-500/30">
            <span className="font-mono text-green-400">{experiment.id}</span> {experiment.title && `- ${experiment.title}`}
          </div>
          {availableSlices.length === 0 ? <div className="text-gray-500 text-center py-4">No slices available</div> : (
            <div className="space-y-3">
              <select value={selectedSlice || ''} onChange={(e) => setSelectedSlice(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg">
                <option value="">Select slice...</option>
                {availableSlices.map(slice => {
                  const mouse = mice.find(m => m.id === slice.mouseId);
                  return <option key={slice.id} value={slice.id}>{slice.id} | {mouse?.mouseNumber || '?'}/{abbrevRegion(slice.region)}/{slice.thickness}Œºm</option>;
                })}
              </select>
              <div><label className="block text-sm text-gray-400 mb-1">Treatment</label>
                <textarea value={treatment} onChange={(e) => setTreatment(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" rows={3} />
              </div>
              <div className="flex gap-2">
                <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
                <button onClick={addSlice} disabled={!selectedSlice} className="flex-1 py-2 bg-purple-600 disabled:bg-gray-600 rounded-lg">Add</button>
              </div>
            </div>
          )}
        </Modal>
      );
    }

    function EditExpSliceModal({ expSlice, onClose }) {
      const { experimentSlices, setExperimentSlices, user, supabase } = useData();
      const [treatment, setTreatment] = useState(expSlice.treatment || '');

      const save = async () => {
        setExperimentSlices(experimentSlices.map(es => es.id === expSlice.id ? { ...es, treatment } : es));
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').update({ treatment }).eq('id', expSlice.id);
        onClose();
      };

      return (
        <Modal title="Edit Treatment" onClose={onClose}>
          <textarea value={treatment} onChange={(e) => setTreatment(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" rows={4} />
          <div className="flex gap-2 mt-4">
            <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
            <button onClick={save} className="flex-1 py-2 bg-purple-600 rounded-lg">Save</button>
          </div>
        </Modal>
      );
    }

    function LabelsTab() {
      const { mice, slices, experiments, experimentSlices, labelConfig, setLabelConfig } = useData();
      const [selectedItems, setSelectedItems] = useState(new Map());
      const [showConfig, setShowConfig] = useState(false);
      const [searchTerm, setSearchTerm] = useState('');

      const expsWithSlices = useMemo(() => {
        return experiments.map(exp => {
          const expSliceLinks = experimentSlices.filter(es => es.experimentId === exp.id);
          const slicesData = expSliceLinks.map(es => {
            const slice = slices.find(s => s.id === es.sliceId);
            const mouse = slice ? mice.find(m => m.id === slice.mouseId) : null;
            return { ...es, slice, mouse, age: getMouseAge(mouse) };
          });
          return { ...exp, slicesData };
        }).filter(exp => exp.slicesData.length > 0);
      }, [experiments, experimentSlices, slices, mice]);

      const filteredExps = useMemo(() => {
        if (!searchTerm) return expsWithSlices;
        const lower = searchTerm.toLowerCase();
        return expsWithSlices.filter(exp => 
          exp.id.toLowerCase().includes(lower) || (exp.title || '').toLowerCase().includes(lower) ||
          exp.slicesData.some(({ slice, mouse }) => (slice?.id || '').toLowerCase().includes(lower) || (mouse?.mouseNumber || '').toLowerCase().includes(lower))
        );
      }, [expsWithSlices, searchTerm]);

      const toggleExp = (expId, sliceIds) => {
        const newSelected = new Map(selectedItems);
        newSelected.has(expId) ? newSelected.delete(expId) : newSelected.set(expId, new Set(sliceIds));
        setSelectedItems(newSelected);
      };

      const toggleSlice = (expId, esId, allIds) => {
        const newSelected = new Map(selectedItems);
        if (!newSelected.has(expId)) { newSelected.set(expId, new Set([esId])); }
        else {
          const set = new Set(newSelected.get(expId));
          set.has(esId) ? set.delete(esId) : set.add(esId);
          set.size === 0 ? newSelected.delete(expId) : newSelected.set(expId, set);
        }
        setSelectedItems(newSelected);
      };

      const selectAll = () => {
        const newSelected = new Map();
        filteredExps.forEach(exp => newSelected.set(exp.id, new Set(exp.slicesData.map(s => s.id))));
        setSelectedItems(newSelected);
      };

      const totalSelected = () => { let c = 0; selectedItems.forEach(s => c += s.size); return c; };

      const printLabels = () => {
        const labelData = [];
        selectedItems.forEach((sliceSet, expId) => {
          const exp = experiments.find(e => e.id === expId);
          sliceSet.forEach(esId => {
            const es = experimentSlices.find(e => e.id === esId);
            const slice = slices.find(s => s.id === es?.sliceId);
            const mouse = slice ? mice.find(m => m.id === slice.mouseId) : null;
            labelData.push({ exp, es, slice, mouse, age: getMouseAge(mouse) });
          });
        });
        if (labelData.length === 0) { alert('Select slices to print'); return; }

        const w = window.open('', '_blank');
        w.document.write(`<!DOCTYPE html><html><head><title>Labels</title>
          <style>
            @media print { @page { margin: 3mm; } }
            * { box-sizing: border-box; }
            body { font-family: 'Courier New', monospace; font-size: ${labelConfig.fontSize}pt; line-height: 1.15; display: flex; flex-wrap: wrap; gap: 2mm; padding: 2mm; margin: 0; }
            .label { border: 0.5pt solid #000; padding: 1.5mm; width: ${labelConfig.labelWidth}mm; max-width: ${labelConfig.labelMaxWidth}mm; page-break-inside: avoid; overflow-wrap: break-word; word-break: break-word; }
            .id { font-weight: bold; font-size: ${labelConfig.fontSize + 0.5}pt; margin-bottom: 0.5mm; }
            .treatment { margin-top: 0.8mm; padding-top: 0.8mm; border-top: 0.4pt dashed #666; white-space: pre-wrap; }
            .row { margin: 0.2mm 0; }
          </style></head><body>
          ${labelData.map(({ exp, es, slice, mouse, age }) => `
            <div class="label">
              ${labelConfig.showExpId ? `<div class="id">${exp?.id || '?'}</div>` : ''}
              ${labelConfig.showMouseInfo && mouse ? `<div class="row">${mouse.mouseNumber || '?'}/${abbrevSex(mouse.sex)}/${age?.months ?? '?'}/${mouse.genotype || '?'}</div>` : ''}
              ${labelConfig.showSliceInfo && slice ? `${labelConfig.showSliceId ? `<div class="row">${slice.id}</div>` : ''}<div class="row">${abbrevRegion(slice.region)}/${slice.thickness || '?'}Œºm${slice.cryosectionDate ? '/' + new Date(slice.cryosectionDate).toLocaleDateString() : ''}</div>` : ''}
              ${labelConfig.showTreatment && es?.treatment ? `<div class="treatment">${es.treatment}</div>` : ''}
            </div>
          `).join('')}
          <script>window.onload = () => window.print();<\/script>
        </body></html>`);
        w.document.close();
      };

      return (
        <div>
          <div className="flex gap-2 mb-4 flex-wrap items-center">
            <input type="text" placeholder="Search..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
            <button onClick={selectAll} className="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm">Select All</button>
            <button onClick={() => setSelectedItems(new Map())} className="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm">Deselect</button>
            <button onClick={() => setShowConfig(true)} className="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm">‚öôÔ∏è Config</button>
            <button onClick={printLabels} disabled={totalSelected() === 0} className="px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-700 rounded-lg text-sm">üñ®Ô∏è Print ({totalSelected()})</button>
          </div>

          <div className="mb-4 p-4 bg-gray-800 rounded-lg border border-gray-700">
            <div className="text-sm text-gray-400 mb-2">Preview ({labelConfig.fontSize}pt, {labelConfig.labelWidth}mm)</div>
            <div className="bg-white text-black p-2 rounded inline-block font-mono" style={{ fontSize: `${labelConfig.fontSize}pt`, width: `${labelConfig.labelWidth * 2.8}px`, wordBreak: 'break-word' }}>
              {labelConfig.showExpId && <div style={{ fontWeight: 'bold' }}>E-SAMPLE</div>}
              {labelConfig.showMouseInfo && <div>M001/M/7/WT</div>}
              {labelConfig.showSliceInfo && <><div>S-SAMPLE</div><div>H/C/16Œºm</div></>}
              {labelConfig.showTreatment && <div style={{ marginTop: '3px', paddingTop: '3px', borderTop: '0.5px dashed #999' }}>10ŒºM Drug</div>}
            </div>
          </div>

          <div className="text-sm text-gray-400 mb-3">{totalSelected()} slice(s) from {selectedItems.size} experiment(s)</div>

          <div className="space-y-3">
            {filteredExps.length === 0 ? <div className="bg-gray-800 rounded-lg border border-gray-700 p-8 text-center text-gray-500">No experiments with slices</div> : filteredExps.map(exp => {
              const expSelected = selectedItems.has(exp.id);
              const selectedSliceIds = selectedItems.get(exp.id) || new Set();
              const allIds = exp.slicesData.map(s => s.id);
              const allSelected = allIds.every(id => selectedSliceIds.has(id));

              return (
                <div key={exp.id} className={`bg-gray-800 rounded-lg border ${expSelected ? 'border-purple-500' : 'border-gray-700'}`}>
                  <div className="p-3 flex items-center gap-3 cursor-pointer hover:bg-gray-700/50" onClick={() => toggleExp(exp.id, allIds)}>
                    <div className={`w-5 h-5 rounded border-2 flex items-center justify-center ${allSelected ? 'border-purple-500 bg-purple-500' : selectedSliceIds.size > 0 ? 'border-purple-500 bg-purple-500/50' : 'border-gray-600'}`}>
                      {(allSelected || selectedSliceIds.size > 0) && <Icon name="Check" className="w-3 h-3 text-white" />}
                    </div>
                    <div className="text-sm">
                      <span className="font-mono text-green-400">{exp.id}</span>
                      {exp.title && <span className="text-white ml-2">| {exp.title}</span>}
                      <span className="text-orange-400 ml-2">| {exp.slicesData.length} slice(s)</span>
                    </div>
                  </div>
                  <div className="border-t border-gray-700 p-2 bg-gray-900/30 space-y-1">
                    {exp.slicesData.map(({ id, slice, mouse, age, treatment }) => {
                      const isSelected = selectedSliceIds.has(id);
                      return (
                        <div key={id} className={`p-2 rounded flex items-center gap-3 cursor-pointer ${isSelected ? 'bg-purple-600/20' : 'hover:bg-gray-700/50'}`} onClick={(e) => { e.stopPropagation(); toggleSlice(exp.id, id, allIds); }}>
                          <div className={`w-4 h-4 rounded border-2 flex items-center justify-center ${isSelected ? 'border-purple-500 bg-purple-500' : 'border-gray-600'}`}>
                            {isSelected && <Icon name="Check" className="w-2.5 h-2.5 text-white" />}
                          </div>
                          <div className="text-sm">
                            <span className="font-mono text-blue-400">{slice?.id || '?'}</span>
                            <span className="text-purple-400 ml-2">{mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{age?.months ?? '?'}m/{mouse?.genotype || '?'}</span>
                            <span className="text-green-400 ml-2">{abbrevRegion(slice?.region)}/{slice?.thickness}Œºm</span>
                            {treatment && <span className="text-yellow-400 text-xs ml-2">‚Üí {treatment}</span>}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>
          {showConfig && <Modal title="Label Config" onClose={() => setShowConfig(false)}><LabelConfigPanel config={labelConfig} setConfig={setLabelConfig} onClose={() => setShowConfig(false)} /></Modal>}
        </div>
      );
    }

    function LabelConfigPanel({ config, setConfig, onClose }) {
      const [local, setLocal] = useState(config);
      return (
        <div className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div><label className="block text-sm text-gray-400 mb-1">Font: {local.fontSize}pt</label>
              <input type="range" min="4" max="16" step="0.5" value={local.fontSize} onChange={(e) => setLocal({ ...local, fontSize: parseFloat(e.target.value) })} className="w-full" /></div>
            <div><label className="block text-sm text-gray-400 mb-1">Width: {local.labelWidth}mm</label>
              <input type="range" min="20" max="80" step="0.5" value={local.labelWidth} onChange={(e) => setLocal({ ...local, labelWidth: parseFloat(e.target.value) })} className="w-full" /></div>
          </div>
          <div className="space-y-2">
            {[{ key: 'showExpId', label: 'Experiment ID' }, { key: 'showSliceId', label: 'Slice ID' }, { key: 'showMouseInfo', label: 'Mouse Info' }, { key: 'showSliceInfo', label: 'Slice Info' }, { key: 'showTreatment', label: 'Treatment' }].map(({ key, label }) => (
              <label key={key} className="flex items-center gap-2 text-sm"><input type="checkbox" checked={local[key] !== false} onChange={(e) => setLocal({ ...local, [key]: e.target.checked })} className="rounded" />{label}</label>
            ))}
          </div>
          <div className="flex gap-2">
            <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
            <button onClick={() => { setConfig(local); onClose(); }} className="flex-1 py-2 bg-purple-600 rounded-lg">Save</button>
          </div>
        </div>
      );
    }

    function SettingsPanel({ onClose }) {
      const { mouseSchema, setMouseSchema, sliceSchema, setSliceSchema, experimentSchema, setExperimentSchema, experimentSliceSchema, setExperimentSliceSchema } = useData();
      const [tab, setTab] = useState('mouse');
      const schemas = {
        mouse: { schema: mouseSchema, setSchema: setMouseSchema, label: 'Mouse' },
        slice: { schema: sliceSchema, setSchema: setSliceSchema, label: 'Slice' },
        experiment: { schema: experimentSchema, setSchema: setExperimentSchema, label: 'Experiment' },
        expSlice: { schema: experimentSliceSchema, setSchema: setExperimentSliceSchema, label: 'Per-Slice' },
      };
      return (
        <div className="space-y-4">
          <div className="flex gap-2 flex-wrap">
            {Object.entries(schemas).map(([key, { label }]) => <button key={key} onClick={() => setTab(key)} className={`px-3 py-1.5 rounded-lg text-sm ${tab === key ? 'bg-purple-600' : 'bg-gray-700'}`}>{label}</button>)}
          </div>
          <SchemaEditor schema={schemas[tab].schema} setSchema={schemas[tab].setSchema} />
          <button onClick={onClose} className="w-full py-2 bg-purple-600 rounded-lg">Done</button>
        </div>
      );
    }

    function SchemaEditor({ schema, setSchema }) {
      const [editing, setEditing] = useState(null);
      const types = [{ value: 'text', label: 'Text' }, { value: 'number', label: 'Number' }, { value: 'date', label: 'Date' }, { value: 'select', label: 'Dropdown' }, { value: 'multicheck', label: 'Checkboxes' }, { value: 'textarea', label: 'Long Text' }, { value: 'multitext', label: 'Multiple Lines' }];
      const updateField = (key, updates) => setSchema(schema.map(f => f.key === key ? { ...f, ...updates } : f));

      return (
        <div className="space-y-2 max-h-96 overflow-y-auto">
          {schema.map((field, index) => (
            <div key={field.key} className="bg-gray-700/50 rounded-lg p-3">
              {editing === field.key ? (
                <div className="space-y-2">
                  <div className="grid grid-cols-2 gap-2">
                    <input type="text" value={field.key} onChange={(e) => updateField(field.key, { key: e.target.value.replace(/\s/g, '_') })} placeholder="Key" className="px-2 py-1 bg-gray-600 rounded text-sm" />
                    <input type="text" value={field.label} onChange={(e) => updateField(field.key, { label: e.target.value })} placeholder="Label" className="px-2 py-1 bg-gray-600 rounded text-sm" />
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    <select value={field.type} onChange={(e) => updateField(field.key, { type: e.target.value })} className="px-2 py-1 bg-gray-600 rounded text-sm">
                      {types.map(t => <option key={t.value} value={t.value}>{t.label}</option>)}
                    </select>
                    <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={field.required || false} onChange={(e) => updateField(field.key, { required: e.target.checked })} />Required</label>
                  </div>
                  {(field.type === 'select' || field.type === 'multicheck') && (
                    <input type="text" value={(field.options || []).join(', ')} onChange={(e) => updateField(field.key, { options: e.target.value.split(',').map(o => o.trim()).filter(Boolean) })} placeholder="Options (comma-sep)" className="w-full px-2 py-1 bg-gray-600 rounded text-sm" />
                  )}
                  <button onClick={() => setEditing(null)} className="w-full py-1 bg-purple-600 rounded text-sm">Done</button>
                </div>
              ) : (
                <div className="flex items-center justify-between">
                  <div><span className="font-medium">{field.label}</span><span className="text-gray-500 text-sm ml-2">({field.type}){field.required && '*'}</span></div>
                  <div className="flex gap-1">
                    <button onClick={() => { const ns = [...schema]; if (index > 0) [ns[index], ns[index-1]] = [ns[index-1], ns[index]]; setSchema(ns); }} disabled={index === 0} className="p-1 hover:bg-gray-600 rounded disabled:opacity-30"><Icon name="ChevronUp" className="w-4 h-4" /></button>
                    <button onClick={() => { const ns = [...schema]; if (index < schema.length-1) [ns[index], ns[index+1]] = [ns[index+1], ns[index]]; setSchema(ns); }} disabled={index === schema.length-1} className="p-1 hover:bg-gray-600 rounded disabled:opacity-30"><Icon name="ChevronDown" className="w-4 h-4" /></button>
                    <button onClick={() => setEditing(field.key)} className="p-1 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                    <button onClick={() => confirm('Delete?') && setSchema(schema.filter(f => f.key !== field.key))} className="p-1 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                  </div>
                </div>
              )}
            </div>
          ))}
          <button onClick={() => { const f = { key: `field_${Date.now()}`, label: 'New Field', type: 'text', required: false }; setSchema([...schema, f]); setEditing(f.key); }} className="w-full py-2 border-2 border-dashed border-gray-600 rounded-lg text-gray-400 hover:text-white">+ Add Field</button>
        </div>
      );
    }

    function DynamicForm({ schema, initialData = {}, onSubmit, onCancel, submitLabel = 'Submit' }) {
      const [form, setForm] = useState(() => {
        const initial = {};
        schema.forEach(field => {
          if (field.type === 'multicheck' || field.type === 'multitext') initial[field.key] = initialData[field.key] || field.default || [];
          else initial[field.key] = initialData[field.key] ?? field.default ?? '';
        });
        return initial;
      });

      const handleSubmit = (e) => {
        e.preventDefault();
        const cleaned = {};
        schema.forEach(field => {
          const v = form[field.key];
          if (field.type === 'number') cleaned[field.key] = v === '' || v === null ? null : Number(v);
          else if (field.type === 'multicheck' || field.type === 'multitext') cleaned[field.key] = v || [];
          else cleaned[field.key] = v === '' ? null : v;
        });
        onSubmit(cleaned);
      };

      const update = (key, value) => setForm({ ...form, [key]: value });
      const toggleMulti = (key, opt) => { const c = form[key] || []; update(key, c.includes(opt) ? c.filter(o => o !== opt) : [...c, opt]); };

      return (
        <form onSubmit={handleSubmit} className="space-y-4 max-h-[60vh] overflow-y-auto">
          {schema.map(field => (
            <div key={field.key}>
              <label className="block text-sm text-gray-400 mb-1">{field.label}{field.required && <span className="text-red-400 ml-1">*</span>}</label>
              {field.type === 'multicheck' ? (
                <div className="flex flex-wrap gap-2">
                  {(field.options || []).map(opt => <label key={opt} className="flex items-center gap-2 bg-gray-700 px-3 py-2 rounded-lg cursor-pointer hover:bg-gray-600"><input type="checkbox" checked={(form[field.key] || []).includes(opt)} onChange={() => toggleMulti(field.key, opt)} />{opt}</label>)}
                </div>
              ) : field.type === 'multitext' ? (
                <div className="space-y-2">
                  {(form[field.key] || []).map((item, i) => (
                    <div key={i} className="flex gap-2">
                      <input type="text" value={item} onChange={(e) => { const c = [...form[field.key]]; c[i] = e.target.value; update(field.key, c); }} className="flex-1 px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-sm" />
                      <button type="button" onClick={() => update(field.key, form[field.key].filter((_, idx) => idx !== i))} className="px-3 py-2 bg-red-600/30 hover:bg-red-600/50 text-red-400 rounded-lg"><Icon name="X" className="w-4 h-4" /></button>
                    </div>
                  ))}
                  <button type="button" onClick={() => update(field.key, [...(form[field.key] || []), ''])} className="w-full py-2 border-2 border-dashed border-gray-600 rounded-lg text-gray-400 text-sm">+ Add</button>
                </div>
              ) : field.type === 'select' ? (
                <select value={form[field.key] || ''} onChange={(e) => update(field.key, e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" required={field.required}>
                  <option value="">{field.required ? 'Select...' : '(Not specified)'}</option>
                  {(field.options || []).map(opt => <option key={opt} value={opt}>{opt}</option>)}
                </select>
              ) : field.type === 'textarea' ? (
                <textarea value={form[field.key] || ''} onChange={(e) => update(field.key, e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg resize-none" rows={3} required={field.required} />
              ) : (
                <input type={field.type === 'number' ? 'number' : field.type === 'date' ? 'date' : 'text'} value={form[field.key] || ''} onChange={(e) => update(field.key, field.type === 'number' ? (e.target.value === '' ? '' : Number(e.target.value)) : e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" required={field.required} />
              )}
            </div>
          ))}
          <div className="flex gap-2 pt-2 sticky bottom-0 bg-gray-800 pb-2">
            <button type="button" onClick={onCancel} className="flex-1 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg">Cancel</button>
            <button type="submit" className="flex-1 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg">{submitLabel}</button>
          </div>
        </form>
      );
    }

    function Modal({ title, children, onClose, large = false }) {
      return (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
          <div className={`bg-gray-800 rounded-xl border border-gray-700 w-full ${large ? 'max-w-2xl' : 'max-w-md'} max-h-[90vh] overflow-auto`}>
            <div className="flex items-center justify-between p-4 border-b border-gray-700 sticky top-0 bg-gray-800 z-10">
              <h2 className="text-lg font-semibold">{title}</h2>
              <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded"><Icon name="X" className="w-5 h-5" /></button>
            </div>
            <div className="p-4">{children}</div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
