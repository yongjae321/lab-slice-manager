<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lab Slice Manager</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #1f2937; }
    ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, createContext, useContext } = React;

    const HARDCODED_SUPABASE_URL = 'https://dcvaenscfybcfalgmrgx.supabase.co';
    const HARDCODED_SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRjdmFlbnNjZnliY2ZhbGdtcmd4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyODk4NjUsImV4cCI6MjA4NDg2NTg2NX0.FVAm8I_ycP531RHalj3wAXjPm-A15AtNDSqRk1Mfu9E';
    
    const getSupabaseConfig = () => {
      const stored = localStorage.getItem('supabase_config');
      if (stored) { try { return JSON.parse(stored); } catch (e) {} }
      return { url: HARDCODED_SUPABASE_URL, key: HARDCODED_SUPABASE_ANON_KEY };
    };
    const saveSupabaseConfig = (url, key) => localStorage.setItem('supabase_config', JSON.stringify({ url, key }));
    const config = getSupabaseConfig();
    const supabase = config.url && config.key ? window.supabase.createClient(config.url, config.key) : null;

    const Icon = ({ name, className = "w-5 h-5" }) => {
      const iconRef = useRef(null);
      useEffect(() => {
        if (iconRef.current && lucide.icons[name]) {
          iconRef.current.innerHTML = '';
          iconRef.current.appendChild(lucide.createElement(lucide.icons[name]));
        }
      }, [name]);
      return <span ref={iconRef} className={`inline-flex items-center justify-center ${className}`} />;
    };

    const DEFAULT_MOUSE_SCHEMA = [
      { key: 'mouseNumber', label: 'Mouse Number', type: 'text', required: true },
      { key: 'sex', label: 'Sex', type: 'select', options: ['M', 'F'], required: false },
      { key: 'genotype', label: 'Genotype', type: 'text', required: false },
      { key: 'labeling', label: 'Labeling', type: 'text', required: false },
      { key: 'birthDate', label: 'Birth Date', type: 'date', required: false },
      { key: 'sacrificeDate', label: 'Sacrifice Date', type: 'date', required: false },
      { key: 'ageMonths', label: 'Age (months)', type: 'number', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_SLICE_SCHEMA = [
      { key: 'region', label: 'Brain Region', type: 'multicheck', options: ['H', 'C'], required: true },
      { key: 'thickness', label: 'Thickness (Œºm)', type: 'number', required: true, default: 16 },
      { key: 'cryosectionDate', label: 'Cryosection Date', type: 'date', required: false },
      { key: 'embeddingMatrix', label: 'Embedding Matrix', type: 'select', options: ['TFM', 'OCT'], required: false, default: 'TFM' },
      { key: 'sliceNumber', label: 'Slice Number', type: 'number', required: false },
      { key: 'quality', label: 'Quality', type: 'select', options: ['Excellent', 'Good', 'Fair', 'Poor'], required: false },
      { key: 'storageLocation', label: 'Storage Location', type: 'text', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_EXPERIMENT_SCHEMA = [
      { key: 'title', label: 'Title', type: 'text', required: false },
      { key: 'experimentDate', label: 'Experiment Date', type: 'date', required: true },
      { key: 'purpose', label: 'Purpose', type: 'textarea', required: false },
      { key: 'protocol', label: 'Protocol', type: 'textarea', required: false },
      { key: 'operator', label: 'Operator', type: 'text', required: false },
      { key: 'results', label: 'Results', type: 'textarea', required: false },
      { key: 'dataFiles', label: 'Data Files', type: 'multitext', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_EXPERIMENT_SLICE_SCHEMA = [
      { key: 'treatment', label: 'Treatment', type: 'textarea', required: false },
      { key: 'notes', label: 'Notes', type: 'textarea', required: false },
    ];

    const DEFAULT_LABEL_CONFIG = {
      fontSize: 7,
      labelWidth: 38,
      labelPadding: 1.0,  // mm, adjustable 0-3mm
      // Line 0: Experiment ID (optional)
      showExpId: false,
      // Line 1: Slice ID
      showSliceId: true,
      // Line 2: Mouse basic (group)
      showMouseBasic: true,
      showMouseNumber: true,
      showSex: true,
      showAge: true,
      // Line 3: Mouse details (group)
      showMouseDetails: true,
      showGenotype: true,
      showLabeling: true,
      // Line 4: Slice info (group)
      showSliceInfo: true,
      showRegion: false,  // OFF by default
      showThickness: true,
      showCryoDate: true,
      // Line 5: Treatment (with separator)
      showTreatment: true,
    };

    function generateId(prefix) {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let id = '';
      for (let i = 0; i < 6; i++) id += chars[Math.floor(Math.random() * chars.length)];
      return `${prefix}-${id.slice(0,4)}-${id.slice(4)}${chars[Math.floor(Math.random() * chars.length)]}${chars[Math.floor(Math.random() * chars.length)]}`;
    }

    function getMouseAge(mouse) {
      if (!mouse) return { months: null, remainingDays: null, isManual: false };
      if (mouse.birthDate) {
        const birth = new Date(mouse.birthDate);
        const ref = mouse.sacrificeDate ? new Date(mouse.sacrificeDate) : new Date();
        const totalDays = Math.floor((ref - birth) / (1000 * 60 * 60 * 24));
        return { months: Math.floor(totalDays / 30.44), remainingDays: Math.floor(totalDays % 30.44), isManual: false };
      }
      if (mouse.ageMonths !== null && mouse.ageMonths !== undefined && mouse.ageMonths !== '') {
        return { months: Number(mouse.ageMonths), remainingDays: null, isManual: true };
      }
      return { months: null, remainingDays: null, isManual: false };
    }

    function abbrevSex(sex) { if (!sex) return '?'; if (sex === 'Male' || sex === 'M') return 'M'; if (sex === 'Female' || sex === 'F') return 'F'; return sex; }
    function abbrevRegion(region) {
      if (!region) return '?';
      if (Array.isArray(region)) return region.map(r => r === 'Hippocampus' || r === 'H' ? 'H' : r === 'Cortex' || r === 'C' ? 'C' : r).join('/');
      return region === 'Hippocampus' ? 'H' : region === 'Cortex' ? 'C' : region;
    }

    const DataContext = createContext(null);
    const useData = () => useContext(DataContext);

    function App() {
      const [user, setUser] = useState(null);
      const [authLoading, setAuthLoading] = useState(true);
      const [mice, setMice] = useState([]);
      const [slices, setSlices] = useState([]);
      const [experiments, setExperiments] = useState([]);
      const [experimentSlices, setExperimentSlices] = useState([]);
      const [mouseSchema, setMouseSchema] = useState(DEFAULT_MOUSE_SCHEMA);
      const [sliceSchema, setSliceSchema] = useState(DEFAULT_SLICE_SCHEMA);
      const [experimentSchema, setExperimentSchema] = useState(DEFAULT_EXPERIMENT_SCHEMA);
      const [experimentSliceSchema, setExperimentSliceSchema] = useState(DEFAULT_EXPERIMENT_SLICE_SCHEMA);
      const [labelConfig, setLabelConfig] = useState(DEFAULT_LABEL_CONFIG);
      const [dataLoaded, setDataLoaded] = useState(false);

      useEffect(() => {
        if (supabase) {
          supabase.auth.getSession().then(({ data: { session } }) => { setUser(session?.user ?? null); setAuthLoading(false); });
          const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => setUser(session?.user ?? null));
          return () => subscription.unsubscribe();
        } else { setAuthLoading(false); }
      }, []);

      useEffect(() => { if (user && !dataLoaded) loadData(); }, [user, dataLoaded]);
      useEffect(() => { if (!user) { setDataLoaded(false); setMice([]); setSlices([]); setExperiments([]); setExperimentSlices([]); } }, [user]);

      const mergeSchemas = (defaultSchema, savedSchema) => {
        const defaultByKey = {}; defaultSchema.forEach(f => { defaultByKey[f.key] = f; });
        const savedKeys = new Set(savedSchema.map(f => f.key));
        const newFields = defaultSchema.filter(f => !savedKeys.has(f.key));
        const updatedSaved = savedSchema.map(f => defaultByKey[f.key] ? { ...f, required: defaultByKey[f.key].required } : f);
        return [...newFields, ...updatedSaved];
      };

      const loadData = async () => {
        if (supabase && user && !user.offline) {
          try {
            const [miceRes, slicesRes, expRes, expSlicesRes, schemaRes] = await Promise.all([
              supabase.from('mice').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('slices').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('experiments').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('experiment_slices').select('*').eq('user_id', user.id).order('created_at', { ascending: false }),
              supabase.from('user_settings').select('*').eq('user_id', user.id).single(),
            ]);
            if (miceRes.data) setMice(miceRes.data);
            if (slicesRes.data) setSlices(slicesRes.data);
            if (expRes.data) setExperiments(expRes.data);
            if (expSlicesRes.data) setExperimentSlices(expSlicesRes.data);
            if (schemaRes.data) {
              if (schemaRes.data.mouse_schema) setMouseSchema(mergeSchemas(DEFAULT_MOUSE_SCHEMA, schemaRes.data.mouse_schema));
              if (schemaRes.data.slice_schema) setSliceSchema(mergeSchemas(DEFAULT_SLICE_SCHEMA, schemaRes.data.slice_schema));
              if (schemaRes.data.experiment_schema) setExperimentSchema(mergeSchemas(DEFAULT_EXPERIMENT_SCHEMA, schemaRes.data.experiment_schema));
              if (schemaRes.data.experiment_slice_schema) setExperimentSliceSchema(mergeSchemas(DEFAULT_EXPERIMENT_SLICE_SCHEMA, schemaRes.data.experiment_slice_schema));
              if (schemaRes.data.label_config) setLabelConfig(schemaRes.data.label_config);
            }
          } catch (err) { console.error('Load error:', err); loadFromLocalStorage(); }
        } else { loadFromLocalStorage(); }
        setDataLoaded(true);
      };
      
      const loadFromLocalStorage = () => {
        const load = (key, setter, defSchema) => {
          const saved = localStorage.getItem(key);
          if (saved) { const parsed = JSON.parse(saved); setter(defSchema ? mergeSchemas(defSchema, parsed) : parsed); }
        };
        load('labManager_mice', setMice); load('labManager_slices', setSlices);
        load('labManager_experiments', setExperiments); load('labManager_experimentSlices', setExperimentSlices);
        load('labManager_mouseSchema', setMouseSchema, DEFAULT_MOUSE_SCHEMA);
        load('labManager_sliceSchema', setSliceSchema, DEFAULT_SLICE_SCHEMA);
        load('labManager_experimentSchema', setExperimentSchema, DEFAULT_EXPERIMENT_SCHEMA);
        load('labManager_experimentSliceSchema', setExperimentSliceSchema, DEFAULT_EXPERIMENT_SLICE_SCHEMA);
        load('labManager_labelConfig', setLabelConfig);
      };

      useEffect(() => {
        if (dataLoaded) {
          localStorage.setItem('labManager_mice', JSON.stringify(mice));
          localStorage.setItem('labManager_slices', JSON.stringify(slices));
          localStorage.setItem('labManager_experiments', JSON.stringify(experiments));
          localStorage.setItem('labManager_experimentSlices', JSON.stringify(experimentSlices));
          localStorage.setItem('labManager_mouseSchema', JSON.stringify(mouseSchema));
          localStorage.setItem('labManager_sliceSchema', JSON.stringify(sliceSchema));
          localStorage.setItem('labManager_experimentSchema', JSON.stringify(experimentSchema));
          localStorage.setItem('labManager_experimentSliceSchema', JSON.stringify(experimentSliceSchema));
          localStorage.setItem('labManager_labelConfig', JSON.stringify(labelConfig));
        }
      }, [mice, slices, experiments, experimentSlices, mouseSchema, sliceSchema, experimentSchema, experimentSliceSchema, labelConfig, dataLoaded]);

      useEffect(() => {
        if (supabase && user && !user.offline && dataLoaded) {
          const timer = setTimeout(async () => {
            await supabase.from('user_settings').upsert({
              user_id: user.id, mouse_schema: mouseSchema, slice_schema: sliceSchema,
              experiment_schema: experimentSchema, experiment_slice_schema: experimentSliceSchema,
              label_config: labelConfig, updated_at: new Date().toISOString(),
            });
          }, 2000);
          return () => clearTimeout(timer);
        }
      }, [mouseSchema, sliceSchema, experimentSchema, experimentSliceSchema, labelConfig]);

      const contextValue = { mice, setMice, slices, setSlices, experiments, setExperiments, experimentSlices, setExperimentSlices, mouseSchema, setMouseSchema, sliceSchema, setSliceSchema, experimentSchema, setExperimentSchema, experimentSliceSchema, setExperimentSliceSchema, labelConfig, setLabelConfig, user, setUser, supabase };

      if (authLoading) return <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center"><div className="animate-spin"><Icon name="Loader2" className="w-8 h-8" /></div></div>;
      if (!user) return <AuthScreen setUser={setUser} />;
      return <DataContext.Provider value={contextValue}><MainLayout /></DataContext.Provider>;
    }

    function AuthScreen({ setUser }) {
      const [email, setEmail] = useState(''); const [otp, setOtp] = useState(''); const [step, setStep] = useState('email');
      const [loading, setLoading] = useState(false); const [message, setMessage] = useState('');
      const [showConfig, setShowConfig] = useState(false);
      const [configUrl, setConfigUrl] = useState(getSupabaseConfig().url);
      const [configKey, setConfigKey] = useState(getSupabaseConfig().key);

      const sendMagicLink = async () => {
        if (!supabase) { setMessage('Configure Supabase first'); return; }
        setLoading(true); setMessage('');
        try {
          const { error } = await supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: window.location.href.split('?')[0] } });
          if (error) throw error;
          setStep('otp'); setMessage('Check email for code or magic link.');
        } catch (err) { setMessage('Error: ' + err.message); }
        setLoading(false);
      };

      const verifyOtp = async () => {
        setLoading(true); setMessage('');
        try {
          const { error } = await supabase.auth.verifyOtp({ email, token: otp, type: 'email' });
          if (error) throw error;
        } catch (err) { setMessage('Error: ' + err.message); }
        setLoading(false);
      };

      const saveConfig = () => { saveSupabaseConfig(configUrl, configKey); window.location.reload(); };

      return (
        <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4">
          <div className="bg-gray-800 rounded-xl p-8 max-w-md w-full border border-gray-700">
            <div className="text-center mb-6">
              <div className="text-4xl mb-2">üß†</div>
              <h1 className="text-2xl font-bold">Lab Slice Manager</h1>
              <p className="text-gray-400 text-sm mt-1">v3.0</p>
            </div>
            {!showConfig ? (
              <>
                {supabase ? (
                  <div className="space-y-4">
                    {step === 'email' ? (
                      <>
                        <input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg" />
                        <button onClick={sendMagicLink} disabled={loading || !email} className="w-full py-3 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded-lg">{loading ? 'Sending...' : 'Send Magic Link'}</button>
                      </>
                    ) : (
                      <>
                        <input type="text" placeholder="000000" value={otp} onChange={(e) => setOtp(e.target.value.replace(/\D/g, '').slice(0, 6))} className="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-center text-2xl tracking-widest" maxLength={6} />
                        <button onClick={verifyOtp} disabled={loading || otp.length !== 6} className="w-full py-3 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded-lg">{loading ? 'Verifying...' : 'Verify'}</button>
                        <button onClick={() => setStep('email')} className="w-full py-2 text-gray-400 text-sm">‚Üê Back</button>
                      </>
                    )}
                    {message && <p className="text-sm text-center text-yellow-400">{message}</p>}
                    <button onClick={() => setShowConfig(true)} className="w-full mt-2 py-2 text-gray-500 hover:text-gray-300 text-sm">‚öôÔ∏è Supabase Settings</button>
                    <div className="border-t border-gray-700 mt-2 pt-3">
                      <button onClick={() => setUser({ offline: true, id: 'offline-user' })} className="w-full py-2 text-gray-500 hover:text-gray-400 text-xs rounded-lg">Use Offline Mode (backup data only)</button>
                    </div>
                  </div>
                ) : (
                  <div className="space-y-4">
                    <p className="text-gray-400 text-sm text-center">Configure Supabase to enable cloud sync and authentication.</p>
                    <button onClick={() => setShowConfig(true)} className="w-full py-3 bg-purple-600 hover:bg-purple-700 rounded-lg">Configure Supabase</button>
                    <div className="border-t border-gray-700 mt-2 pt-3">
                      <button onClick={() => setUser({ offline: true, id: 'offline-user' })} className="w-full py-2 text-gray-500 hover:text-gray-400 text-xs rounded-lg">Use Offline Mode (backup data only)</button>
                    </div>
                  </div>
                )}
              </>
            ) : (
              <div className="space-y-4">
                <input type="text" placeholder="https://xxx.supabase.co" value={configUrl} onChange={(e) => setConfigUrl(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-sm" />
                <input type="text" placeholder="anon key" value={configKey} onChange={(e) => setConfigKey(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-sm" />
                <div className="flex gap-2">
                  <button onClick={() => setShowConfig(false)} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
                  <button onClick={saveConfig} className="flex-1 py-2 bg-purple-600 rounded-lg">Save</button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function MainLayout() {
      const { user, setUser, supabase, mice, slices, experiments, experimentSlices, setMice, setSlices, setExperiments, setExperimentSlices } = useData();
      const [activeTab, setActiveTab] = useState('mice');
      const [showSettings, setShowSettings] = useState(false);
      const [showExport, setShowExport] = useState(false);

      const exportData = () => {
        const data = { mice, slices, experiments, experimentSlices, exportedAt: new Date().toISOString(), version: '3.0' };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `backup-${new Date().toISOString().split('T')[0]}.json`; a.click();
      };

      const importData = (e) => {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const data = JSON.parse(event.target.result);
            if (data.mice) setMice(data.mice);
            if (data.slices) setSlices(data.slices);
            if (data.experiments) setExperiments(data.experiments);
            if (data.experimentSlices) setExperimentSlices(data.experimentSlices);
            if (supabase && user && !user.offline) {
              for (const m of (data.mice || [])) await supabase.from('mice').upsert({ ...m, user_id: user.id });
              for (const s of (data.slices || [])) await supabase.from('slices').upsert({ ...s, user_id: user.id });
              for (const exp of (data.experiments || [])) await supabase.from('experiments').upsert({ ...exp, user_id: user.id });
              for (const es of (data.experimentSlices || [])) await supabase.from('experiment_slices').upsert({ ...es, user_id: user.id });
            }
            alert('Imported!');
          } catch (err) { alert('Error: ' + err.message); }
        };
        reader.readAsText(file);
      };

      const tabs = [{ key: 'mice', label: 'Mice', icon: 'Mouse' }, { key: 'slices', label: 'Slices', icon: 'Layers' }, { key: 'experiments', label: 'Experiments', icon: 'FlaskConical' }, { key: 'labels', label: 'Labels', icon: 'Tag' }];

      return (
        <div className="min-h-screen bg-gray-900 text-white">
          <header className="bg-gray-800 border-b border-gray-700 sticky top-0 z-40">
            <div className="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
              <div className="flex items-center gap-3"><span className="text-2xl">üß†</span><span className="font-semibold hidden sm:block">Lab Slice Manager</span></div>
              <div className="flex items-center gap-2">
                <button onClick={() => setShowExport(true)} className="p-2 hover:bg-gray-700 rounded-lg"><Icon name="Database" className="w-5 h-5" /></button>
                <button onClick={() => setShowSettings(true)} className="p-2 hover:bg-gray-700 rounded-lg"><Icon name="Settings" className="w-5 h-5" /></button>
                <button onClick={async () => { if (supabase) { await supabase.auth.signOut(); } setUser(null); }} className="p-2 hover:bg-gray-700 rounded-lg text-gray-400"><Icon name="LogOut" className="w-5 h-5" /></button>
              </div>
            </div>
            <nav className="max-w-7xl mx-auto px-4 flex gap-1 overflow-x-auto">
              {tabs.map(tab => <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex items-center gap-2 px-4 py-2 rounded-t-lg ${activeTab === tab.key ? 'bg-gray-900 text-white' : 'text-gray-400 hover:bg-gray-700/50'}`}><Icon name={tab.icon} className="w-4 h-4" />{tab.label}</button>)}
            </nav>
          </header>
          <main className="max-w-7xl mx-auto p-4">
            {activeTab === 'mice' && <MiceTab />}
            {activeTab === 'slices' && <SlicesTab />}
            {activeTab === 'experiments' && <ExperimentsTab />}
            {activeTab === 'labels' && <LabelsTab />}
          </main>
          {showSettings && <Modal title="Settings" onClose={() => setShowSettings(false)} large><SettingsPanel onClose={() => setShowSettings(false)} /></Modal>}
          {showExport && <Modal title="Import/Export" onClose={() => setShowExport(false)}>
            <div className="space-y-4">
              <button onClick={exportData} className="w-full py-3 bg-purple-600 hover:bg-purple-700 rounded-lg">Export Data</button>
              <label className="w-full py-3 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center cursor-pointer">Import<input type="file" accept=".json" onChange={importData} className="hidden" /></label>
            </div>
          </Modal>}
        </div>
      );
    }

    function SortableHeader({ label, sortKey, currentSort, onSort }) {
      const isActive = currentSort.key === sortKey;
      return <th className="px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase cursor-pointer hover:text-white" onClick={() => onSort(sortKey)}>{label} {isActive && (currentSort.direction === 'asc' ? '‚Üë' : '‚Üì')}</th>;
    }

    function MiceTab() {
      const { mice, setMice, slices, mouseSchema, user, supabase } = useData();
      const [showAdd, setShowAdd] = useState(false);
      const [editingMouse, setEditingMouse] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [sort, setSort] = useState({ key: 'created_at', direction: 'desc' });

      const handleSort = (key) => setSort(prev => ({ key, direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc' }));

      const sortedMice = useMemo(() => {
        let filtered = mice.filter(m => !searchTerm || Object.values(m).some(v => String(v).toLowerCase().includes(searchTerm.toLowerCase())));
        return filtered.sort((a, b) => {
          let aVal, bVal;
          if (sort.key === 'age') { const ageA = getMouseAge(a); const ageB = getMouseAge(b); aVal = ageA.months ?? -1; bVal = ageB.months ?? -1; }
          else { aVal = a[sort.key] ?? ''; bVal = b[sort.key] ?? ''; }
          return sort.direction === 'asc' ? (aVal < bVal ? -1 : 1) : (aVal > bVal ? -1 : 1);
        });
      }, [mice, searchTerm, sort]);

      const addMouse = async (data) => {
        const newMouse = { id: generateId('M'), ...data, created_at: new Date().toISOString() };
        setMice([newMouse, ...mice]); setShowAdd(false);
        if (supabase && user && !user.offline) {
          const { error } = await supabase.from('mice').insert({ ...newMouse, user_id: user.id });
          if (error) alert('Cloud error: ' + error.message);
        }
      };

      const updateMouse = async (data) => {
        setMice(mice.map(m => m.id === editingMouse.id ? { ...m, ...data } : m)); setEditingMouse(null);
        if (supabase && user && !user.offline) await supabase.from('mice').update(data).eq('id', editingMouse.id);
      };

      const deleteMouse = async (id) => {
        if (slices.some(s => s.mouseId === id)) { alert('Delete slices first'); return; }
        if (!confirm('Delete?')) return;
        setMice(mice.filter(m => m.id !== id));
        if (supabase && user && !user.offline) await supabase.from('mice').delete().eq('id', id);
      };

      return (
        <div>
          <div className="flex gap-2 mb-4 flex-wrap">
            <input type="text" placeholder="Search..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
            <button onClick={() => setShowAdd(true)} className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg flex items-center gap-2"><Icon name="Plus" className="w-4 h-4" />Add Mouse</button>
          </div>
          <div className="flex gap-2 mb-3 text-xs flex-wrap">
            {[{ key: 'mouseNumber', label: 'Mouse#' }, { key: 'sex', label: 'Sex' }, { key: 'age', label: 'Age' }, { key: 'created_at', label: 'Added' }].map(({ key, label }) => (
              <button key={key} onClick={() => handleSort(key)} className={`px-2 py-1 rounded ${sort.key === key ? 'bg-purple-600' : 'bg-gray-700'}`}>{label}</button>
            ))}
          </div>
          <div className="overflow-x-auto bg-gray-800 rounded-lg border border-gray-700">
            <table className="w-full">
              <thead className="bg-gray-900/50"><tr>
                <SortableHeader label="Mouse#" sortKey="mouseNumber" currentSort={sort} onSort={handleSort} />
                <th className="px-3 py-2 text-left text-xs text-gray-400">Sex</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Genotype</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Labeling</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Age</th>
                <th className="px-3 py-2 text-left text-xs text-gray-400">Slices</th>
                <th className="px-3 py-2 text-right text-xs text-gray-400">Actions</th>
              </tr></thead>
              <tbody className="divide-y divide-gray-700">
                {sortedMice.length === 0 ? <tr><td colSpan="7" className="py-8 text-center text-gray-500">No mice</td></tr> : sortedMice.map(mouse => {
                  const age = getMouseAge(mouse);
                  return (
                    <tr key={mouse.id} className="hover:bg-gray-700/50">
                      <td className="px-3 py-2 font-medium">{mouse.mouseNumber || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{mouse.sex || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{mouse.genotype || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{mouse.labeling || 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{age.months !== null ? `${age.months}m${age.remainingDays ? ` ${age.remainingDays}d` : ''}` : 'N/A'}</td>
                      <td className="px-3 py-2 text-gray-300">{slices.filter(s => s.mouseId === mouse.id).length}</td>
                      <td className="px-3 py-2 text-right">
                        <button onClick={(e) => { e.stopPropagation(); setEditingMouse({ ...mouse, _ts: Date.now() }); }} className="p-1 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                        <button onClick={() => deleteMouse(mouse.id)} className="p-1 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
          {showAdd && <Modal title="Add Mouse" onClose={() => setShowAdd(false)}><DynamicForm schema={mouseSchema} onSubmit={addMouse} onCancel={() => setShowAdd(false)} submitLabel="Add" /></Modal>}
          {editingMouse && <Modal key={editingMouse._ts} title="Edit Mouse" onClose={() => setEditingMouse(null)}><DynamicForm schema={mouseSchema} initialData={editingMouse} onSubmit={updateMouse} onCancel={() => setEditingMouse(null)} submitLabel="Save" /></Modal>}
        </div>
      );
    }

    function SlicesTab() {
      const { mice, slices, setSlices, experiments, experimentSlices, setExperimentSlices, setExperiments, sliceSchema, experimentSchema, user, supabase } = useData();
      const [showAdd, setShowAdd] = useState(false);
      const [addingSliceForMouse, setAddingSliceForMouse] = useState(null);
      const [editingSlice, setEditingSlice] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [sliceSort, setSliceSort] = useState({ key: 'created_at', direction: 'desc' });
      const [mouseSort, setMouseSort] = useState({ key: 'mouseNumber', direction: 'asc' });
      const [addingExpForSlice, setAddingExpForSlice] = useState(null);

      const handleMouseSort = (key) => setMouseSort(prev => ({ key, direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc' }));
      const handleSliceSort = (key) => setSliceSort(prev => ({ key, direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc' }));

      const sortedMice = useMemo(() => {
        return [...mice].sort((a, b) => {
          let aVal, bVal;
          if (mouseSort.key === 'age') { const ageA = getMouseAge(a); const ageB = getMouseAge(b); aVal = ageA.months ?? -1; bVal = ageB.months ?? -1; }
          else if (mouseSort.key === 'sliceCount') { aVal = slices.filter(s => s.mouseId === a.id).length; bVal = slices.filter(s => s.mouseId === b.id).length; }
          else { aVal = a[mouseSort.key] ?? ''; bVal = b[mouseSort.key] ?? ''; }
          return mouseSort.direction === 'asc' ? (aVal < bVal ? -1 : 1) : (aVal > bVal ? -1 : 1);
        });
      }, [mice, slices, mouseSort]);

      const sortedSlices = useMemo(() => {
        let filtered = slices.filter(s => {
          if (!searchTerm) return true;
          const mouse = mice.find(m => m.id === s.mouseId);
          const searchLower = searchTerm.toLowerCase();
          return s.id.toLowerCase().includes(searchLower) || (mouse?.mouseNumber || '').toLowerCase().includes(searchLower) || (s.region?.join(' ') || '').toLowerCase().includes(searchLower);
        });
        return filtered.sort((a, b) => {
          let aVal = a[sliceSort.key] ?? '', bVal = b[sliceSort.key] ?? '';
          return sliceSort.direction === 'asc' ? (aVal < bVal ? -1 : 1) : (aVal > bVal ? -1 : 1);
        });
      }, [slices, mice, searchTerm, sliceSort]);

      const addSlice = async (data) => {
        const newSlice = { id: generateId('S'), mouseId: addingSliceForMouse.id, ...data, created_at: new Date().toISOString() };
        setSlices([newSlice, ...slices]); setShowAdd(false); setAddingSliceForMouse(null);
        if (supabase && user && !user.offline) await supabase.from('slices').insert({ ...newSlice, user_id: user.id });
      };

      const updateSlice = async (data) => {
        setSlices(slices.map(s => s.id === editingSlice.id ? { ...s, ...data } : s)); setEditingSlice(null);
        if (supabase && user && !user.offline) await supabase.from('slices').update(data).eq('id', editingSlice.id);
      };

      const deleteSlice = async (id) => {
        if (experimentSlices.some(es => es.sliceId === id)) { alert('Remove from experiments first'); return; }
        if (!confirm('Delete?')) return;
        setSlices(slices.filter(s => s.id !== id));
        if (supabase && user && !user.offline) await supabase.from('slices').delete().eq('id', id);
      };

      return (
        <div>
          {/* Mice Table - Add slice for mouse */}
          <div className="mb-6">
            <div className="text-sm text-gray-400 mb-2">Add slice for mouse:</div>
            <div className="flex gap-2 mb-2 text-xs flex-wrap">
              {[{ key: 'mouseNumber', label: 'Mouse#' }, { key: 'sex', label: 'Sex' }, { key: 'age', label: 'Age' }, { key: 'sliceCount', label: 'Slices' }].map(({ key, label }) => (
                <button key={key} onClick={() => handleMouseSort(key)} className={`px-2 py-1 rounded ${mouseSort.key === key ? 'bg-purple-600' : 'bg-gray-700'}`}>{label} {mouseSort.key === key && (mouseSort.direction === 'asc' ? '‚Üë' : '‚Üì')}</button>
              ))}
            </div>
            <div className="overflow-x-auto bg-gray-800 rounded-lg border border-gray-700">
              <table className="w-full">
                <thead className="bg-gray-900/50"><tr>
                  <th className="px-3 py-2 text-left text-xs text-gray-400">Mouse#</th>
                  <th className="px-3 py-2 text-left text-xs text-gray-400">Sex</th>
                  <th className="px-3 py-2 text-left text-xs text-gray-400">Genotype</th>
                  <th className="px-3 py-2 text-left text-xs text-gray-400">Age</th>
                  <th className="px-3 py-2 text-left text-xs text-gray-400">Slices</th>
                  <th className="px-3 py-2 text-right text-xs text-gray-400">Add</th>
                </tr></thead>
                <tbody className="divide-y divide-gray-700">
                  {sortedMice.length === 0 ? <tr><td colSpan="6" className="py-4 text-center text-gray-500">No mice - add mice first</td></tr> : sortedMice.map(mouse => {
                    const age = getMouseAge(mouse);
                    const sliceCount = slices.filter(s => s.mouseId === mouse.id).length;
                    return (
                      <tr key={mouse.id} className="hover:bg-gray-700/50">
                        <td className="px-3 py-2 font-medium">{mouse.mouseNumber || 'N/A'}</td>
                        <td className="px-3 py-2 text-gray-300">{abbrevSex(mouse.sex)}</td>
                        <td className="px-3 py-2 text-gray-300">{mouse.genotype || 'N/A'}</td>
                        <td className="px-3 py-2 text-gray-300">{age.months !== null ? `${age.months}m` : 'N/A'}</td>
                        <td className="px-3 py-2 text-gray-300">{sliceCount}</td>
                        <td className="px-3 py-2 text-right">
                          <button onClick={() => { setAddingSliceForMouse(mouse); setShowAdd(true); }} className="p-1.5 hover:bg-purple-600/30 rounded text-purple-400"><Icon name="Plus" className="w-4 h-4" /></button>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>

          {/* Slices List */}
          <div className="flex gap-2 mb-4 flex-wrap">
            <input type="text" placeholder="Search slices..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
          </div>
          <div className="flex gap-2 mb-3 text-xs flex-wrap">
            {[{ key: 'id', label: 'ID' }, { key: 'created_at', label: 'Added' }].map(({ key, label }) => (
              <button key={key} onClick={() => handleSliceSort(key)} className={`px-2 py-1 rounded ${sliceSort.key === key ? 'bg-purple-600' : 'bg-gray-700'}`}>{label} {sliceSort.key === key && (sliceSort.direction === 'asc' ? '‚Üë' : '‚Üì')}</button>
            ))}
          </div>
          <div className="grid gap-2">
            {sortedSlices.length === 0 ? <div className="bg-gray-800 rounded-lg border border-gray-700 p-8 text-center text-gray-500">No slices</div> : sortedSlices.map(slice => {
              const mouse = mice.find(m => m.id === slice.mouseId);
              const age = getMouseAge(mouse);
              const expCount = experimentSlices.filter(es => es.sliceId === slice.id).length;
              return (
                <div key={slice.id} className="bg-gray-800 rounded-lg border border-gray-700 p-3 flex items-center justify-between">
                  <div className="flex items-center gap-2 flex-wrap text-sm">
                    <span className="font-mono text-blue-400">{slice.id}</span>
                    <span className="text-gray-500">|</span>
                    <span className="text-purple-400">{mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{age?.months ?? '?'}m/{mouse?.genotype || '?'}</span>
                    <span className="text-gray-500">|</span>
                    <span className="text-green-400">{abbrevRegion(slice.region)}/{slice.thickness}Œºm</span>
                    {expCount > 0 && <span className="text-orange-400 text-xs">({expCount} exp)</span>}
                  </div>
                  <div className="flex items-center gap-1">
                    <button onClick={() => setAddingExpForSlice({ ...slice, _ts: Date.now() })} className="p-1.5 hover:bg-purple-600/30 rounded text-purple-400" title="Add to Experiment"><Icon name="FlaskConical" className="w-4 h-4" /></button>
                    <button onClick={(e) => { e.stopPropagation(); setEditingSlice({ ...slice, _ts: Date.now() }); }} className="p-1.5 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                    <button onClick={() => deleteSlice(slice.id)} className="p-1.5 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                  </div>
                </div>
              );
            })}
          </div>
          {showAdd && addingSliceForMouse && <Modal title="Add Slice" onClose={() => { setShowAdd(false); setAddingSliceForMouse(null); }}>
            <div className="mb-4 p-3 bg-purple-600/20 rounded-lg border border-purple-500/30">For: {addingSliceForMouse.mouseNumber} ({abbrevSex(addingSliceForMouse.sex)})</div>
            <DynamicForm schema={sliceSchema} onSubmit={addSlice} onCancel={() => { setShowAdd(false); setAddingSliceForMouse(null); }} submitLabel="Add" />
          </Modal>}
          {editingSlice && <Modal key={editingSlice._ts} title="Edit Slice" onClose={() => setEditingSlice(null)}><DynamicForm schema={sliceSchema} initialData={editingSlice} onSubmit={updateSlice} onCancel={() => setEditingSlice(null)} submitLabel="Save" /></Modal>}
          {addingExpForSlice && <AddSliceToExpModal key={addingExpForSlice._ts} slice={addingExpForSlice} onClose={() => setAddingExpForSlice(null)} />}
        </div>
      );
    }

    function AddSliceToExpModal({ slice, onClose }) {
      const { mice, experiments, experimentSlices, setExperiments, setExperimentSlices, experimentSchema, user, supabase } = useData();
      const [mode, setMode] = useState('choose');
      const [selectedExp, setSelectedExp] = useState(null);
      const [treatment, setTreatment] = useState('');
      const [notes, setNotes] = useState('');

      const mouse = mice.find(m => m.id === slice.mouseId);
      const availableExps = experiments;

      const createNewExp = async (expData) => {
        const newExp = { id: generateId('E'), ...expData, created_at: new Date().toISOString() };
        setExperiments([newExp, ...experiments]);
        if (supabase && user && !user.offline) await supabase.from('experiments').insert({ ...newExp, user_id: user.id });
        const newLink = { id: generateId('ES'), experimentId: newExp.id, sliceId: slice.id, treatment, notes, created_at: new Date().toISOString() };
        setExperimentSlices([newLink, ...experimentSlices]);
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').insert({ ...newLink, user_id: user.id });
        onClose();
      };

      const addToExisting = async () => {
        if (!selectedExp) return;
        const newLink = { id: generateId('ES'), experimentId: selectedExp, sliceId: slice.id, treatment, notes, created_at: new Date().toISOString() };
        setExperimentSlices([newLink, ...experimentSlices]);
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').insert({ ...newLink, user_id: user.id });
        onClose();
      };

      return (
        <Modal title="Add to Experiment" onClose={onClose} large>
          <div className="mb-4 p-3 bg-blue-600/20 rounded-lg border border-blue-500/30">
            <span className="font-mono text-blue-400">{slice.id}</span> | {mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{abbrevRegion(slice.region)}
          </div>
          {mode === 'choose' && (
            <div className="space-y-3">
              <button onClick={() => setMode('new')} className="w-full p-4 bg-purple-600/20 hover:bg-purple-600/30 border border-purple-500/50 rounded-lg text-left">
                <div className="font-medium">Create New Experiment</div>
              </button>
              <button onClick={() => setMode('existing')} disabled={availableExps.length === 0} className="w-full p-4 bg-green-600/20 hover:bg-green-600/30 disabled:bg-gray-700/50 border border-green-500/50 disabled:border-gray-600 rounded-lg text-left">
                <div className="font-medium">Add to Existing ({availableExps.length})</div>
              </button>
            </div>
          )}
          {mode === 'new' && (
            <div>
              <button onClick={() => setMode('choose')} className="mb-4 text-sm text-gray-400 hover:text-white">‚Üê Back</button>
              <div className="mb-4"><label className="block text-sm text-gray-400 mb-1">Treatment (optional)</label>
                <textarea value={treatment} onChange={(e) => setTreatment(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" rows={2} />
              </div>
              <DynamicForm schema={experimentSchema} onSubmit={createNewExp} onCancel={onClose} submitLabel="Create & Add" />
            </div>
          )}
          {mode === 'existing' && (
            <div>
              <button onClick={() => setMode('choose')} className="mb-4 text-sm text-gray-400 hover:text-white">‚Üê Back</button>
              <select value={selectedExp || ''} onChange={(e) => setSelectedExp(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg mb-3">
                <option value="">Select...</option>
                {availableExps.map(exp => <option key={exp.id} value={exp.id}>{exp.id} - {exp.title || 'Untitled'}</option>)}
              </select>
              <div className="mb-3"><label className="block text-sm text-gray-400 mb-1">Treatment</label>
                <textarea value={treatment} onChange={(e) => setTreatment(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" rows={2} />
              </div>
              <div className="flex gap-2">
                <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
                <button onClick={addToExisting} disabled={!selectedExp} className="flex-1 py-2 bg-purple-600 disabled:bg-gray-600 rounded-lg">Add</button>
              </div>
            </div>
          )}
        </Modal>
      );
    }

    function ExperimentsTab() {
      const { mice, slices, experiments, setExperiments, experimentSlices, setExperimentSlices, experimentSchema, user, supabase } = useData();
      const [showAdd, setShowAdd] = useState(false);
      const [editingExp, setEditingExp] = useState(null);
      const [expandedExp, setExpandedExp] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [addingSliceToExp, setAddingSliceToExp] = useState(null);
      const [editingExpSlice, setEditingExpSlice] = useState(null);

      const sortedExps = useMemo(() => {
        return experiments.filter(exp => !searchTerm || exp.id.toLowerCase().includes(searchTerm.toLowerCase()) || (exp.title || '').toLowerCase().includes(searchTerm.toLowerCase()))
          .sort((a, b) => (b.created_at || '').localeCompare(a.created_at || ''));
      }, [experiments, searchTerm]);

      const addExp = async (data) => {
        const newExp = { id: generateId('E'), ...data, created_at: new Date().toISOString() };
        setExperiments([newExp, ...experiments]); setShowAdd(false);
        if (supabase && user && !user.offline) await supabase.from('experiments').insert({ ...newExp, user_id: user.id });
      };

      const updateExp = async (data) => {
        setExperiments(experiments.map(e => e.id === editingExp.id ? { ...e, ...data } : e)); setEditingExp(null);
        if (supabase && user && !user.offline) await supabase.from('experiments').update(data).eq('id', editingExp.id);
      };

      const deleteExp = async (id) => {
        const links = experimentSlices.filter(es => es.experimentId === id);
        if (links.length > 0 && !confirm(`Delete experiment and ${links.length} slice link(s)?`)) return;
        if (links.length === 0 && !confirm('Delete?')) return;
        setExperimentSlices(experimentSlices.filter(es => es.experimentId !== id));
        setExperiments(experiments.filter(e => e.id !== id));
        if (supabase && user && !user.offline) {
          await supabase.from('experiment_slices').delete().eq('experimentId', id);
          await supabase.from('experiments').delete().eq('id', id);
        }
      };

      const removeSliceLink = async (esId) => {
        if (!confirm('Remove slice from experiment?')) return;
        setExperimentSlices(experimentSlices.filter(es => es.id !== esId));
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').delete().eq('id', esId);
      };

      const getExpSlices = (expId) => experimentSlices.filter(es => es.experimentId === expId).map(es => {
        const slice = slices.find(s => s.id === es.sliceId);
        const mouse = slice ? mice.find(m => m.id === slice.mouseId) : null;
        return { ...es, slice, mouse };
      });

      return (
        <div>
          <div className="flex gap-2 mb-4 flex-wrap">
            <input type="text" placeholder="Search..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
            <button onClick={() => setShowAdd(true)} className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg flex items-center gap-2"><Icon name="Plus" className="w-4 h-4" />New Experiment</button>
          </div>
          <div className="space-y-3">
            {sortedExps.length === 0 ? <div className="bg-gray-800 rounded-lg border border-gray-700 p-8 text-center text-gray-500">No experiments</div> : sortedExps.map(exp => {
              const expSlices = getExpSlices(exp.id);
              const isExpanded = expandedExp === exp.id;
              return (
                <div key={exp.id} className="bg-gray-800 rounded-lg border border-gray-700 overflow-hidden">
                  <div className="p-3 flex items-center justify-between cursor-pointer hover:bg-gray-700/50" onClick={() => setExpandedExp(isExpanded ? null : exp.id)}>
                    <div className="flex items-center gap-2 text-sm">
                      <Icon name={isExpanded ? 'ChevronDown' : 'ChevronRight'} className="w-5 h-5 text-gray-400" />
                      <span className="font-mono text-green-400">{exp.id}</span>
                      {exp.title && <span className="text-white">| {exp.title}</span>}
                      {exp.experimentDate && <span className="text-gray-400">| {new Date(exp.experimentDate).toLocaleDateString()}</span>}
                      <span className="text-orange-400">| {expSlices.length} slice(s)</span>
                    </div>
                    <div className="flex items-center gap-1" onClick={(e) => e.stopPropagation()}>
                      <button onClick={(e) => { e.stopPropagation(); setAddingSliceToExp({ ...exp, _ts: Date.now() }); }} className="p-1.5 hover:bg-purple-600/30 rounded text-purple-400"><Icon name="Plus" className="w-4 h-4" /></button>
                      <button onClick={(e) => { e.stopPropagation(); setEditingExp({ ...exp, _ts: Date.now() }); }} className="p-1.5 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                      <button onClick={() => deleteExp(exp.id)} className="p-1.5 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                    </div>
                  </div>
                  {isExpanded && (
                    <div className="border-t border-gray-700 p-3 bg-gray-900/50">
                      {exp.purpose && <div className="text-sm mb-2"><span className="text-gray-500">Purpose: </span>{exp.purpose}</div>}
                      {exp.protocol && <div className="text-sm mb-2 whitespace-pre-wrap"><span className="text-gray-500">Protocol: </span>{exp.protocol}</div>}
                      <div className="mt-3 text-sm font-medium text-gray-400 mb-2">Slices:</div>
                      {expSlices.length === 0 ? <div className="text-gray-500 text-sm italic">No slices</div> : (
                        <div className="space-y-2">
                          {expSlices.map(({ id, slice, mouse, treatment }) => {
                            const age = getMouseAge(mouse);
                            return (
                              <div key={id} className="bg-gray-800 rounded-lg p-2 flex items-center justify-between text-sm">
                                <div>
                                  <span className="font-mono text-blue-400">{slice?.id || '?'}</span>
                                  <span className="text-purple-400 ml-2">{mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{age?.months ?? '?'}m</span>
                                  <span className="text-green-400 ml-2">{abbrevRegion(slice?.region)}/{slice?.thickness}Œºm</span>
                                  {treatment && <div className="text-yellow-400 text-xs mt-1">‚Üí {treatment}</div>}
                                </div>
                                <div className="flex gap-1" onClick={(e) => e.stopPropagation()}>
                                  <button onClick={(e) => { e.stopPropagation(); setEditingExpSlice({ id, treatment, _ts: Date.now() }); }} className="p-1 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-3 h-3" /></button>
                                  <button onClick={(e) => { e.stopPropagation(); removeSliceLink(id); }} className="p-1 hover:bg-red-600/30 rounded text-red-400"><Icon name="X" className="w-3 h-3" /></button>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
          {showAdd && <Modal title="New Experiment" onClose={() => setShowAdd(false)} large><DynamicForm schema={experimentSchema} onSubmit={addExp} onCancel={() => setShowAdd(false)} submitLabel="Create" /></Modal>}
          {editingExp && <Modal key={editingExp._ts} title="Edit Experiment" onClose={() => setEditingExp(null)} large><DynamicForm schema={experimentSchema} initialData={editingExp} onSubmit={updateExp} onCancel={() => setEditingExp(null)} submitLabel="Save" /></Modal>}
          {addingSliceToExp && <AddSliceToExpFromExpTab key={addingSliceToExp._ts} experiment={addingSliceToExp} onClose={() => setAddingSliceToExp(null)} />}
          {editingExpSlice && <EditExpSliceModal key={editingExpSlice._ts} expSlice={editingExpSlice} onClose={() => setEditingExpSlice(null)} />}
        </div>
      );
    }

    function AddSliceToExpFromExpTab({ experiment, onClose }) {
      const { mice, slices, experimentSlices, setExperimentSlices, user, supabase } = useData();
      const [selectedSlice, setSelectedSlice] = useState(null);
      const [treatment, setTreatment] = useState('');

      const availableSlices = slices;

      const addSlice = async () => {
        if (!selectedSlice) return;
        const newLink = { id: generateId('ES'), experimentId: experiment.id, sliceId: selectedSlice, treatment, created_at: new Date().toISOString() };
        setExperimentSlices([newLink, ...experimentSlices]);
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').insert({ ...newLink, user_id: user.id });
        onClose();
      };

      return (
        <Modal title="Add Slice" onClose={onClose}>
          <div className="mb-4 p-3 bg-green-600/20 rounded-lg border border-green-500/30">
            <span className="font-mono text-green-400">{experiment.id}</span> {experiment.title && `- ${experiment.title}`}
          </div>
          {availableSlices.length === 0 ? <div className="text-gray-500 text-center py-4">No slices available</div> : (
            <div className="space-y-3">
              <select value={selectedSlice || ''} onChange={(e) => setSelectedSlice(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500">
                <option value="">Select slice...</option>
                {availableSlices.map(slice => {
                  const mouse = mice.find(m => m.id === slice.mouseId);
                  return <option key={slice.id} value={slice.id}>{slice.id} | {mouse?.mouseNumber || '?'}/{abbrevRegion(slice.region)}/{slice.thickness}Œºm</option>;
                })}
              </select>
              <div><label className="block text-sm text-gray-400 mb-1">Treatment</label>
                <textarea value={treatment} onChange={(e) => setTreatment(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500" rows={3} />
              </div>
              <div className="flex gap-2">
                <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
                <button onClick={addSlice} disabled={!selectedSlice} className="flex-1 py-2 bg-purple-600 disabled:bg-gray-600 rounded-lg">Add</button>
              </div>
            </div>
          )}
        </Modal>
      );
    }

    function EditExpSliceModal({ expSlice, onClose }) {
      const { experimentSlices, setExperimentSlices, user, supabase } = useData();
      const [treatment, setTreatment] = useState(expSlice.treatment || '');
      const textareaRef = useRef(null);

      useEffect(() => {
        // Force focus after render
        const timer = setTimeout(() => {
          if (textareaRef.current) {
            textareaRef.current.focus();
          }
        }, 50);
        return () => clearTimeout(timer);
      }, []);

      const save = async () => {
        setExperimentSlices(experimentSlices.map(es => es.id === expSlice.id ? { ...es, treatment } : es));
        if (supabase && user && !user.offline) await supabase.from('experiment_slices').update({ treatment }).eq('id', expSlice.id);
        onClose();
      };

      return (
        <Modal title="Edit Treatment" onClose={onClose}>
          <textarea 
            ref={textareaRef}
            value={treatment} 
            onChange={(e) => setTreatment(e.target.value)} 
            onMouseDown={(e) => e.stopPropagation()}
            onClick={(e) => { e.stopPropagation(); textareaRef.current?.focus(); }}
            className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500" 
            rows={4}
            autoFocus
          />
          <div className="flex gap-2 mt-4">
            <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
            <button onClick={save} className="flex-1 py-2 bg-purple-600 rounded-lg">Save</button>
          </div>
        </Modal>
      );
    }

    function LabelsTab() {
      const { mice, slices, experiments, experimentSlices, labelConfig, setLabelConfig } = useData();
      const [selectedItems, setSelectedItems] = useState(new Map());
      const [showConfig, setShowConfig] = useState(false);
      const [searchTerm, setSearchTerm] = useState('');

      const expsWithSlices = useMemo(() => {
        return experiments.map(exp => {
          const expSliceLinks = experimentSlices.filter(es => es.experimentId === exp.id);
          const slicesData = expSliceLinks.map(es => {
            const slice = slices.find(s => s.id === es.sliceId);
            const mouse = slice ? mice.find(m => m.id === slice.mouseId) : null;
            return { ...es, slice, mouse, age: getMouseAge(mouse) };
          });
          return { ...exp, slicesData };
        }).filter(exp => exp.slicesData.length > 0);
      }, [experiments, experimentSlices, slices, mice]);

      const filteredExps = useMemo(() => {
        if (!searchTerm) return expsWithSlices;
        const lower = searchTerm.toLowerCase();
        return expsWithSlices.filter(exp => 
          exp.id.toLowerCase().includes(lower) || (exp.title || '').toLowerCase().includes(lower) ||
          exp.slicesData.some(({ slice, mouse }) => (slice?.id || '').toLowerCase().includes(lower) || (mouse?.mouseNumber || '').toLowerCase().includes(lower))
        );
      }, [expsWithSlices, searchTerm]);

      const toggleExp = (expId, sliceIds) => {
        const newSelected = new Map(selectedItems);
        newSelected.has(expId) ? newSelected.delete(expId) : newSelected.set(expId, new Set(sliceIds));
        setSelectedItems(newSelected);
      };

      const toggleSlice = (expId, esId, allIds) => {
        const newSelected = new Map(selectedItems);
        if (!newSelected.has(expId)) { newSelected.set(expId, new Set([esId])); }
        else {
          const set = new Set(newSelected.get(expId));
          set.has(esId) ? set.delete(esId) : set.add(esId);
          set.size === 0 ? newSelected.delete(expId) : newSelected.set(expId, set);
        }
        setSelectedItems(newSelected);
      };

      const selectAll = () => {
        const newSelected = new Map();
        filteredExps.forEach(exp => newSelected.set(exp.id, new Set(exp.slicesData.map(s => s.id))));
        setSelectedItems(newSelected);
      };

      const totalSelected = () => { let c = 0; selectedItems.forEach(s => c += s.size); return c; };

      const printLabels = () => {
        const labelData = [];
        selectedItems.forEach((sliceSet, expId) => {
          const exp = experiments.find(e => e.id === expId);
          sliceSet.forEach(esId => {
            const es = experimentSlices.find(e => e.id === esId);
            const slice = slices.find(s => s.id === es?.sliceId);
            const mouse = slice ? mice.find(m => m.id === slice.mouseId) : null;
            labelData.push({ exp, es, slice, mouse, age: getMouseAge(mouse) });
          });
        });
        if (labelData.length === 0) { alert('Select slices to print'); return; }

        const cfg = labelConfig;
        const w = window.open('', '_blank');
        w.document.write(`<!DOCTYPE html><html><head><title>Labels</title>
          <style>
            @media print { @page { margin: 3mm; } }
            * { box-sizing: border-box; margin: 0; padding: 0; }
            body { font-family: 'Courier New', monospace; font-size: ${cfg.fontSize}pt; line-height: 1.1; display: flex; flex-wrap: wrap; gap: 2mm; padding: 2mm; }
            .label { border: 0.5pt solid #000; padding: ${cfg.labelPadding ?? 1}mm; width: ${cfg.labelWidth}mm; page-break-inside: avoid; overflow-wrap: break-word; word-break: break-word; }
            .id { font-weight: bold; font-size: ${cfg.fontSize + 0.5}pt; }
            .treatment { margin-top: 0.5mm; padding-top: 0.5mm; border-top: 0.4pt dashed #666; white-space: pre-wrap; }
          </style></head><body>
          ${labelData.map(({ exp, es, slice, mouse, age }) => {
            // Build each line conditionally
            // Line 0: Experiment ID (optional)
            const line0 = cfg.showExpId ? `<div class="id">${exp?.id || '?'}</div>` : '';
            
            // Line 1: Slice ID
            const line1 = cfg.showSliceId ? `<div class="id">${slice?.id || '?'}</div>` : '';
            
            // Line 2: Mouse basic (number/sex/age)
            let line2Parts = [];
            if (cfg.showMouseBasic) {
              if (cfg.showMouseNumber) line2Parts.push(mouse?.mouseNumber || '?');
              if (cfg.showSex) line2Parts.push(abbrevSex(mouse?.sex));
              if (cfg.showAge) line2Parts.push((age?.months ?? '?') + 'm');
            }
            const line2 = line2Parts.length > 0 ? `<div>${line2Parts.join('/')}</div>` : '';
            
            // Line 3: Mouse details (genotype/labeling)
            let line3Parts = [];
            if (cfg.showMouseDetails) {
              if (cfg.showGenotype && mouse?.genotype) line3Parts.push(mouse.genotype);
              if (cfg.showLabeling && mouse?.labeling) line3Parts.push(mouse.labeling);
            }
            const line3 = line3Parts.length > 0 ? `<div>${line3Parts.join('/')}</div>` : '';
            
            // Line 4: Slice info (region/thickness/cryoDate)
            let line4Parts = [];
            if (cfg.showSliceInfo) {
              if (cfg.showRegion && slice?.region) line4Parts.push(abbrevRegion(slice.region));
              if (cfg.showThickness && slice?.thickness) line4Parts.push(slice.thickness + 'Œºm');
              if (cfg.showCryoDate && slice?.cryosectionDate) {
                const d = new Date(slice.cryosectionDate);
                line4Parts.push((d.getMonth()+1) + '/' + d.getDate());
              }
            }
            const line4 = line4Parts.length > 0 ? `<div>${line4Parts.join('/')}</div>` : '';
            
            // Line 5: Treatment (with separator)
            const line5 = cfg.showTreatment && es?.treatment ? `<div class="treatment">${es.treatment}</div>` : '';
            
            return `<div class="label">${line0}${line1}${line2}${line3}${line4}${line5}</div>`;
          }).join('')}
          <script>window.onload = () => window.print();<\/script>
        </body></html>`);
        w.document.close();
      };

      return (
        <div>
          <div className="flex gap-2 mb-4 flex-wrap items-center">
            <input type="text" placeholder="Search..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="flex-1 min-w-[200px] px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg" />
            <button onClick={selectAll} className="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm">Select All</button>
            <button onClick={() => setSelectedItems(new Map())} className="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm">Deselect</button>
            <button onClick={() => setShowConfig(true)} className="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm">‚öôÔ∏è Config</button>
            <button onClick={printLabels} disabled={totalSelected() === 0} className="px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-700 rounded-lg text-sm">üñ®Ô∏è Print ({totalSelected()})</button>
          </div>

          <div className="mb-4 p-4 bg-gray-800 rounded-lg border border-gray-700">
            <div className="text-sm text-gray-400 mb-2">Preview ({labelConfig.fontSize}pt, {labelConfig.labelWidth}mm, pad:{labelConfig.labelPadding ?? 1}mm)</div>
            <div className="bg-white text-black rounded inline-block font-mono border border-gray-400" style={{ fontSize: `${labelConfig.fontSize}pt`, width: `${labelConfig.labelWidth * 2.8}px`, padding: `${(labelConfig.labelPadding ?? 1) * 3.78}px`, lineHeight: 1.1, wordBreak: 'break-word' }}>
              {labelConfig.showExpId && <div style={{ fontWeight: 'bold' }}>E-XXXX-XX</div>}
              {labelConfig.showSliceId && <div style={{ fontWeight: 'bold' }}>S-XXXX-XX</div>}
              {labelConfig.showMouseBasic && <div>
                {[labelConfig.showMouseNumber && 'M001', labelConfig.showSex && 'M', labelConfig.showAge && '7m'].filter(Boolean).join('/')}
              </div>}
              {labelConfig.showMouseDetails && <div>
                {[labelConfig.showGenotype && 'WT', labelConfig.showLabeling && 'GFP+'].filter(Boolean).join('/')}
              </div>}
              {labelConfig.showSliceInfo && <div>
                {[labelConfig.showRegion && 'H', labelConfig.showThickness && '16Œºm', labelConfig.showCryoDate && '1/30'].filter(Boolean).join('/')}
              </div>}
              {labelConfig.showTreatment && <div style={{ marginTop: '3px', paddingTop: '3px', borderTop: '0.5px dashed #999' }}>10ŒºM Drug</div>}
            </div>
          </div>

          <div className="text-sm text-gray-400 mb-3">{totalSelected()} slice(s) from {selectedItems.size} experiment(s)</div>

          <div className="space-y-3">
            {filteredExps.length === 0 ? <div className="bg-gray-800 rounded-lg border border-gray-700 p-8 text-center text-gray-500">No experiments with slices</div> : filteredExps.map(exp => {
              const expSelected = selectedItems.has(exp.id);
              const selectedSliceIds = selectedItems.get(exp.id) || new Set();
              const allIds = exp.slicesData.map(s => s.id);
              const allSelected = allIds.every(id => selectedSliceIds.has(id));

              return (
                <div key={exp.id} className={`bg-gray-800 rounded-lg border ${expSelected ? 'border-purple-500' : 'border-gray-700'}`}>
                  <div className="p-3 flex items-center gap-3 cursor-pointer hover:bg-gray-700/50" onClick={() => toggleExp(exp.id, allIds)}>
                    <div className={`w-5 h-5 rounded border-2 flex items-center justify-center ${allSelected ? 'border-purple-500 bg-purple-500' : selectedSliceIds.size > 0 ? 'border-purple-500 bg-purple-500/50' : 'border-gray-600'}`}>
                      {(allSelected || selectedSliceIds.size > 0) && <Icon name="Check" className="w-3 h-3 text-white" />}
                    </div>
                    <div className="text-sm">
                      <span className="font-mono text-green-400">{exp.id}</span>
                      {exp.title && <span className="text-white ml-2">| {exp.title}</span>}
                      <span className="text-orange-400 ml-2">| {exp.slicesData.length} slice(s)</span>
                    </div>
                  </div>
                  <div className="border-t border-gray-700 p-2 bg-gray-900/30 space-y-1">
                    {exp.slicesData.map(({ id, slice, mouse, age, treatment }) => {
                      const isSelected = selectedSliceIds.has(id);
                      return (
                        <div key={id} className={`p-2 rounded flex items-center gap-3 cursor-pointer ${isSelected ? 'bg-purple-600/20' : 'hover:bg-gray-700/50'}`} onClick={(e) => { e.stopPropagation(); toggleSlice(exp.id, id, allIds); }}>
                          <div className={`w-4 h-4 rounded border-2 flex items-center justify-center ${isSelected ? 'border-purple-500 bg-purple-500' : 'border-gray-600'}`}>
                            {isSelected && <Icon name="Check" className="w-2.5 h-2.5 text-white" />}
                          </div>
                          <div className="text-sm">
                            <span className="font-mono text-blue-400">{slice?.id || '?'}</span>
                            <span className="text-purple-400 ml-2">{mouse?.mouseNumber || '?'}/{abbrevSex(mouse?.sex)}/{age?.months ?? '?'}m/{mouse?.genotype || '?'}</span>
                            <span className="text-green-400 ml-2">{abbrevRegion(slice?.region)}/{slice?.thickness}Œºm</span>
                            {treatment && <span className="text-yellow-400 text-xs ml-2">‚Üí {treatment}</span>}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>
          {showConfig && <Modal title="Label Config" onClose={() => setShowConfig(false)}><LabelConfigPanel config={labelConfig} setConfig={setLabelConfig} onClose={() => setShowConfig(false)} /></Modal>}
        </div>
      );
    }

    function LabelConfigPanel({ config, setConfig, onClose }) {
      const [local, setLocal] = useState(config);
      
      // Toggle group and all its children
      const toggleGroup = (groupKey, childKeys) => {
        const newState = !local[groupKey];
        const updates = { [groupKey]: newState };
        childKeys.forEach(k => { updates[k] = newState; });
        setLocal({ ...local, ...updates });
      };
      
      // Toggle individual field
      const toggleField = (key) => setLocal({ ...local, [key]: !local[key] });
      
      // Check if all children in a group are enabled
      const allChildrenEnabled = (childKeys) => childKeys.every(k => local[k]);
      const someChildrenEnabled = (childKeys) => childKeys.some(k => local[k]);
      
      // Hierarchical checkbox component
      const GroupCheckbox = ({ groupKey, label, childKeys, children }) => {
        const allEnabled = allChildrenEnabled(childKeys);
        const someEnabled = someChildrenEnabled(childKeys);
        return (
          <div className="border border-gray-700 rounded-lg p-3 space-y-2">
            <label className="flex items-center gap-2 text-sm font-medium cursor-pointer">
              <input
                type="checkbox"
                checked={local[groupKey]}
                ref={el => { if (el) el.indeterminate = local[groupKey] && someEnabled && !allEnabled; }}
                onChange={() => toggleGroup(groupKey, childKeys)}
                className="rounded"
              />
              {label}
            </label>
            {local[groupKey] && (
              <div className="ml-6 space-y-1 text-sm text-gray-300">
                {children}
              </div>
            )}
          </div>
        );
      };
      
      const FieldCheckbox = ({ fieldKey, label }) => (
        <label className="flex items-center gap-2 cursor-pointer">
          <input type="checkbox" checked={local[fieldKey]} onChange={() => toggleField(fieldKey)} className="rounded" />
          {label}
        </label>
      );
      
      return (
        <div className="space-y-4">
          {/* Size controls */}
          <div className="grid grid-cols-3 gap-3">
            <div>
              <label className="block text-sm text-gray-400 mb-1">Font: {local.fontSize}pt</label>
              <input type="range" min="4" max="16" step="0.5" value={local.fontSize} onChange={(e) => setLocal({ ...local, fontSize: parseFloat(e.target.value) })} className="w-full" />
            </div>
            <div>
              <label className="block text-sm text-gray-400 mb-1">Width: {local.labelWidth}mm</label>
              <input type="range" min="20" max="80" step="0.5" value={local.labelWidth} onChange={(e) => setLocal({ ...local, labelWidth: parseFloat(e.target.value) })} className="w-full" />
            </div>
            <div>
              <label className="block text-sm text-gray-400 mb-1">Padding: {local.labelPadding ?? 1}mm</label>
              <input type="range" min="0" max="3" step="0.1" value={local.labelPadding ?? 1} onChange={(e) => setLocal({ ...local, labelPadding: parseFloat(e.target.value) })} className="w-full" />
            </div>
          </div>
          
          <div className="text-xs text-gray-500 border-t border-gray-700 pt-3">Label Lines (top to bottom)</div>
          
          {/* Line 0: Experiment ID (optional) */}
          <label className="flex items-center gap-2 text-sm border border-gray-700 rounded-lg p-3 cursor-pointer">
            <input type="checkbox" checked={local.showExpId} onChange={() => toggleField('showExpId')} className="rounded" />
            <span className="font-medium">Experiment ID</span>
            <span className="text-gray-500 text-xs">(E-XXXX-XX)</span>
          </label>
          
          {/* Line 1: Slice ID */}
          <label className="flex items-center gap-2 text-sm border border-gray-700 rounded-lg p-3 cursor-pointer">
            <input type="checkbox" checked={local.showSliceId} onChange={() => toggleField('showSliceId')} className="rounded" />
            <span className="font-medium">Slice ID</span>
            <span className="text-gray-500 text-xs">(S-XXXX-XX)</span>
          </label>
          
          {/* Line 2: Mouse Basic */}
          <GroupCheckbox groupKey="showMouseBasic" label="Mouse Basic" childKeys={['showMouseNumber', 'showSex', 'showAge']}>
            <FieldCheckbox fieldKey="showMouseNumber" label="Mouse Number" />
            <FieldCheckbox fieldKey="showSex" label="Sex (M/F)" />
            <FieldCheckbox fieldKey="showAge" label="Age (months)" />
          </GroupCheckbox>
          
          {/* Line 3: Mouse Details */}
          <GroupCheckbox groupKey="showMouseDetails" label="Mouse Details" childKeys={['showGenotype', 'showLabeling']}>
            <FieldCheckbox fieldKey="showGenotype" label="Genotype" />
            <FieldCheckbox fieldKey="showLabeling" label="Labeling" />
          </GroupCheckbox>
          
          {/* Line 4: Slice Info */}
          <GroupCheckbox groupKey="showSliceInfo" label="Slice Info" childKeys={['showRegion', 'showThickness', 'showCryoDate']}>
            <FieldCheckbox fieldKey="showRegion" label="Region (H/C)" />
            <FieldCheckbox fieldKey="showThickness" label="Thickness (Œºm)" />
            <FieldCheckbox fieldKey="showCryoDate" label="Cryosection Date" />
          </GroupCheckbox>
          
          {/* Treatment */}
          <label className="flex items-center gap-2 text-sm border border-gray-700 rounded-lg p-3 cursor-pointer">
            <input type="checkbox" checked={local.showTreatment} onChange={() => toggleField('showTreatment')} className="rounded" />
            <span className="font-medium">Treatment</span>
            <span className="text-gray-500 text-xs">(with separator line)</span>
          </label>
          
          {/* Buttons */}
          <div className="flex gap-2 pt-2">
            <button onClick={onClose} className="flex-1 py-2 bg-gray-700 rounded-lg">Cancel</button>
            <button onClick={() => { setConfig(local); onClose(); }} className="flex-1 py-2 bg-purple-600 rounded-lg">Save</button>
          </div>
        </div>
      );
    }

    function SettingsPanel({ onClose }) {
      const { mouseSchema, setMouseSchema, sliceSchema, setSliceSchema, experimentSchema, setExperimentSchema, experimentSliceSchema, setExperimentSliceSchema } = useData();
      const [tab, setTab] = useState('mouse');
      const schemas = {
        mouse: { schema: mouseSchema, setSchema: setMouseSchema, label: 'Mouse' },
        slice: { schema: sliceSchema, setSchema: setSliceSchema, label: 'Slice' },
        experiment: { schema: experimentSchema, setSchema: setExperimentSchema, label: 'Experiment' },
        expSlice: { schema: experimentSliceSchema, setSchema: setExperimentSliceSchema, label: 'Per-Slice' },
      };
      return (
        <div className="space-y-4">
          <div className="flex gap-2 flex-wrap">
            {Object.entries(schemas).map(([key, { label }]) => <button key={key} onClick={() => setTab(key)} className={`px-3 py-1.5 rounded-lg text-sm ${tab === key ? 'bg-purple-600' : 'bg-gray-700'}`}>{label}</button>)}
          </div>
          <SchemaEditor schema={schemas[tab].schema} setSchema={schemas[tab].setSchema} />
          <button onClick={onClose} className="w-full py-2 bg-purple-600 rounded-lg">Done</button>
        </div>
      );
    }

    function SchemaEditor({ schema, setSchema }) {
      const [editing, setEditing] = useState(null);
      const types = [{ value: 'text', label: 'Text' }, { value: 'number', label: 'Number' }, { value: 'date', label: 'Date' }, { value: 'select', label: 'Dropdown' }, { value: 'multicheck', label: 'Checkboxes' }, { value: 'textarea', label: 'Long Text' }, { value: 'multitext', label: 'Multiple Lines' }];
      const updateField = (key, updates) => setSchema(schema.map(f => f.key === key ? { ...f, ...updates } : f));

      return (
        <div className="space-y-2 max-h-96 overflow-y-auto">
          {schema.map((field, index) => (
            <div key={field.key} className="bg-gray-700/50 rounded-lg p-3">
              {editing === field.key ? (
                <div className="space-y-2">
                  <div className="grid grid-cols-2 gap-2">
                    <input type="text" value={field.key} onChange={(e) => updateField(field.key, { key: e.target.value.replace(/\s/g, '_') })} placeholder="Key" className="px-2 py-1 bg-gray-600 rounded text-sm" />
                    <input type="text" value={field.label} onChange={(e) => updateField(field.key, { label: e.target.value })} placeholder="Label" className="px-2 py-1 bg-gray-600 rounded text-sm" />
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    <select value={field.type} onChange={(e) => updateField(field.key, { type: e.target.value })} className="px-2 py-1 bg-gray-600 rounded text-sm">
                      {types.map(t => <option key={t.value} value={t.value}>{t.label}</option>)}
                    </select>
                    <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={field.required || false} onChange={(e) => updateField(field.key, { required: e.target.checked })} />Required</label>
                  </div>
                  {(field.type === 'select' || field.type === 'multicheck') && (
                    <input type="text" value={(field.options || []).join(', ')} onChange={(e) => updateField(field.key, { options: e.target.value.split(',').map(o => o.trim()).filter(Boolean) })} placeholder="Options (comma-sep)" className="w-full px-2 py-1 bg-gray-600 rounded text-sm" />
                  )}
                  <button onClick={() => setEditing(null)} className="w-full py-1 bg-purple-600 rounded text-sm">Done</button>
                </div>
              ) : (
                <div className="flex items-center justify-between">
                  <div><span className="font-medium">{field.label}</span><span className="text-gray-500 text-sm ml-2">({field.type}){field.required && '*'}</span></div>
                  <div className="flex gap-1">
                    <button onClick={() => { const ns = [...schema]; if (index > 0) [ns[index], ns[index-1]] = [ns[index-1], ns[index]]; setSchema(ns); }} disabled={index === 0} className="p-1 hover:bg-gray-600 rounded disabled:opacity-30"><Icon name="ChevronUp" className="w-4 h-4" /></button>
                    <button onClick={() => { const ns = [...schema]; if (index < schema.length-1) [ns[index], ns[index+1]] = [ns[index+1], ns[index]]; setSchema(ns); }} disabled={index === schema.length-1} className="p-1 hover:bg-gray-600 rounded disabled:opacity-30"><Icon name="ChevronDown" className="w-4 h-4" /></button>
                    <button onClick={() => setEditing(field.key)} className="p-1 hover:bg-gray-600 rounded"><Icon name="Pencil" className="w-4 h-4" /></button>
                    <button onClick={() => confirm('Delete?') && setSchema(schema.filter(f => f.key !== field.key))} className="p-1 hover:bg-red-600/30 rounded text-red-400"><Icon name="Trash2" className="w-4 h-4" /></button>
                  </div>
                </div>
              )}
            </div>
          ))}
          <button onClick={() => { const f = { key: `field_${Date.now()}`, label: 'New Field', type: 'text', required: false }; setSchema([...schema, f]); setEditing(f.key); }} className="w-full py-2 border-2 border-dashed border-gray-600 rounded-lg text-gray-400 hover:text-white">+ Add Field</button>
        </div>
      );
    }

    function DynamicForm({ schema, initialData = {}, onSubmit, onCancel, submitLabel = 'Submit' }) {
      const [form, setForm] = useState(() => {
        const initial = {};
        schema.forEach(field => {
          if (field.type === 'multicheck' || field.type === 'multitext') initial[field.key] = initialData[field.key] || field.default || [];
          else initial[field.key] = initialData[field.key] ?? field.default ?? '';
        });
        return initial;
      });

      const handleSubmit = (e) => {
        e.preventDefault();
        const cleaned = {};
        schema.forEach(field => {
          const v = form[field.key];
          if (field.type === 'number') cleaned[field.key] = v === '' || v === null ? null : Number(v);
          else if (field.type === 'multicheck' || field.type === 'multitext') cleaned[field.key] = v || [];
          else cleaned[field.key] = v === '' ? null : v;
        });
        onSubmit(cleaned);
      };

      const update = (key, value) => setForm({ ...form, [key]: value });
      const toggleMulti = (key, opt) => { const c = form[key] || []; update(key, c.includes(opt) ? c.filter(o => o !== opt) : [...c, opt]); };

      return (
        <form onSubmit={handleSubmit} className="space-y-4 max-h-[60vh] overflow-y-auto">
          {schema.map(field => (
            <div key={field.key}>
              <label className="block text-sm text-gray-400 mb-1">{field.label}{field.required && <span className="text-red-400 ml-1">*</span>}</label>
              {field.type === 'multicheck' ? (
                <div className="flex flex-wrap gap-2">
                  {(field.options || []).map(opt => <label key={opt} className="flex items-center gap-2 bg-gray-700 px-3 py-2 rounded-lg cursor-pointer hover:bg-gray-600"><input type="checkbox" checked={(form[field.key] || []).includes(opt)} onChange={() => toggleMulti(field.key, opt)} />{opt}</label>)}
                </div>
              ) : field.type === 'multitext' ? (
                <div className="space-y-2">
                  {(form[field.key] || []).map((item, i) => (
                    <div key={i} className="flex gap-2">
                      <input type="text" value={item} onChange={(e) => { const c = [...form[field.key]]; c[i] = e.target.value; update(field.key, c); }} className="flex-1 px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-sm" />
                      <button type="button" onClick={() => update(field.key, form[field.key].filter((_, idx) => idx !== i))} className="px-3 py-2 bg-red-600/30 hover:bg-red-600/50 text-red-400 rounded-lg"><Icon name="X" className="w-4 h-4" /></button>
                    </div>
                  ))}
                  <button type="button" onClick={() => update(field.key, [...(form[field.key] || []), ''])} className="w-full py-2 border-2 border-dashed border-gray-600 rounded-lg text-gray-400 text-sm">+ Add</button>
                </div>
              ) : field.type === 'select' ? (
                <select value={form[field.key] || ''} onChange={(e) => update(field.key, e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" required={field.required}>
                  <option value="">{field.required ? 'Select...' : '(Not specified)'}</option>
                  {(field.options || []).map(opt => <option key={opt} value={opt}>{opt}</option>)}
                </select>
              ) : field.type === 'textarea' ? (
                <textarea value={form[field.key] || ''} onChange={(e) => update(field.key, e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg resize-none" rows={3} required={field.required} />
              ) : (
                <input type={field.type === 'number' ? 'number' : field.type === 'date' ? 'date' : 'text'} value={form[field.key] || ''} onChange={(e) => update(field.key, field.type === 'number' ? (e.target.value === '' ? '' : Number(e.target.value)) : e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg" required={field.required} />
              )}
            </div>
          ))}
          <div className="flex gap-2 pt-2 sticky bottom-0 bg-gray-800 pb-2">
            <button type="button" onClick={onCancel} className="flex-1 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg">Cancel</button>
            <button type="submit" className="flex-1 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg">{submitLabel}</button>
          </div>
        </form>
      );
    }

    function Modal({ title, children, onClose, large = false }) {
      return (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50" onClick={onClose} onMouseDown={(e) => e.target === e.currentTarget && e.stopPropagation()}>
          <div className={`bg-gray-800 rounded-xl border border-gray-700 w-full ${large ? 'max-w-2xl' : 'max-w-md'} max-h-[90vh] overflow-auto`} onClick={(e) => e.stopPropagation()} onMouseDown={(e) => e.stopPropagation()}>
            <div className="flex items-center justify-between p-4 border-b border-gray-700 sticky top-0 bg-gray-800 z-10">
              <h2 className="text-lg font-semibold">{title}</h2>
              <button onClick={onClose} className="p-1 hover:bg-gray-700 rounded"><Icon name="X" className="w-5 h-5" /></button>
            </div>
            <div className="p-4">{children}</div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
